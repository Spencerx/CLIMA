<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DGmethods · CLIMA</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="CLIMA logo"/></a><h1>CLIMA</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Utilites</span><ul><li><a class="toctext" href="../Utilities/RootSolvers/">RootSolvers</a></li><li><a class="toctext" href="../Utilities/MoistThermodynamics/">MoistThermodynamics</a></li></ul></li><li><span class="toctext">Atmos</span><ul><li><a class="toctext" href="../Atmos/SurfaceFluxes/"><code>SurfaceFluxes</code></a></li><li><a class="toctext" href="../Atmos/TurbulenceConvection/"><code>TurbulenceConvection</code></a></li><li><a class="toctext" href="../Atmos/EDMFEquations/">Eddy-Diffusivity Mass-Flux (EDMF) equations</a></li></ul></li><li><a class="toctext" href="../ODESolvers/">ODESolvers</a></li><li><a class="toctext" href="../Mesh/">Mesh</a></li><li><a class="toctext" href="../AtmosDycore/">AtmosDycore</a></li><li><a class="toctext" href="../Arrays/">Arrays</a></li><li class="current"><a class="toctext" href>DGmethods</a><ul class="internal"><li><a class="toctext" href="#SpaceMethods-1"><code>SpaceMethods</code></a></li><li><a class="toctext" href="#DGBalanceLawDiscretizations-1"><code>DGBalanceLawDiscretizations</code></a></li><li><a class="toctext" href="#DGBalanceLawDiscretizations.NumericalFluxes-1"><code>DGBalanceLawDiscretizations.NumericalFluxes</code></a></li></ul></li><li><span class="toctext">Developer docs</span><ul><li><a class="toctext" href="../CodingConventions/">Coding Conventions</a></li><li><a class="toctext" href="../AcceptableUnicode/">Acceptable Unicode characters</a></li><li><a class="toctext" href="../VariableList/">CliMA Variable List</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DGmethods</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/CLIMA/blob/master/docs/src/DGmethods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DGmethods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ODESolvers-1" href="#ODESolvers-1">ODESolvers</a></h1><h2><a class="nav-anchor" id="SpaceMethods-1" href="#SpaceMethods-1"><code>SpaceMethods</code></a></h2><p>Set of abstract types for spatial discretizations</p><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.AbstractSpaceMethod" href="#CLIMA.SpaceMethods.AbstractSpaceMethod"><code>CLIMA.SpaceMethods.AbstractSpaceMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSpaceMethod</code></pre><p>Supertype for spatial discretizations</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/SpaceMethods.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.AbstractDGMethod" href="#CLIMA.SpaceMethods.AbstractDGMethod"><code>CLIMA.SpaceMethods.AbstractDGMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractDGMethod &lt;: AbstractSpaceMethod</code></pre><p>Supertype for discontinuous Galerkin spatial discretizations</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/SpaceMethods.jl#L12-L16">source</a></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.odefun!" href="#CLIMA.SpaceMethods.odefun!"><code>CLIMA.SpaceMethods.odefun!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">odefun!(disc::DGBalanceLaw, dQ::MPIStateArray, Q::MPIStateArray, t)</code></pre><p>Evaluates the right-hand side of the discontinuous Galerkin semi-discretization defined by <code>disc</code> at time <code>t</code> with state <code>Q</code>. The result is added into <code>dQ</code>. Namely, the semi-discretization is of the form</p><div>\[Q̇ = F(Q, t)\]</div><p>and after the call <code>dQ += F(Q, t)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L436-L446">source</a><div><div><pre><code class="language-julia">odefun!(disc::AbstractSpaceMethod, dQ, Q, t)</code></pre><p>Evaluates the right-hand side of the spatial discretization defined by <code>disc</code> at time <code>t</code> with state <code>Q</code>. The result is added into <code>dQ</code>. Namely, the semi-discretization is of the form <span>$Q̇ = F(Q, t)$</span> and after the call <code>dQ += F(Q, t)</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>There is no generic implementation of this function. This must be implemented for each subtype of <code>AbstractSpaceMethod</code></p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/SpaceMethods.jl#L19-L34">source</a></section><h2><a class="nav-anchor" id="DGBalanceLawDiscretizations-1" href="#DGBalanceLawDiscretizations-1"><code>DGBalanceLawDiscretizations</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations" href="#CLIMA.DGBalanceLawDiscretizations"><code>CLIMA.DGBalanceLawDiscretizations</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>DG Balance Law Discretizations module. Attempts to provide a reasonable implementation of a discontinuous Galerkin method (in weak form) on tensor product quadrilateral (2D) and hexahedral (3D) elements for balance laws of the form</p><div>\[q_{,t} + Σ_{i=1,...d} F_{i,i} = s\]</div><p>where <span>$q$</span> is the state vector, <span>$F$</span> is the flux function, and <span>$s$</span> is the source function. <span>$F$</span> includes both the &quot;inviscid&quot; and &quot;viscous&quot; fluxes. Note that this is a space only discretization, time must be advanced using some ordinary differential equations methods; see <a href="@ref"><code>ODESolvers</code></a>.</p><p>Much of the notation used in this module follows Hesthaven and Warburton (2008).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>We plan to switch to a skew-symmetric formulation (at which time this note will be removed)</p></div></div><div class="admonition references"><div class="admonition-title">References</div><div class="admonition-text"><pre><code class="language-none">@BOOK{HesthavenWarburton2008,
  title = {Nodal Discontinuous {G}alerkin Methods: {A}lgorithms, Analysis,
           and Applications},
  publisher = {Springer-Verlag New York},
  year = {2008},
  author = {Hesthaven, Jan S. and Warburton, Tim},
  volume = {54},
  series = {Texts in Applied Mathematics},
  doi = {10.1007/978-0-387-72067-8}
}</code></pre></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L1-L37">source</a></section><h3><a class="nav-anchor" id="Types-2" href="#Types-2">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw" href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DGBalanceLaw &lt;: AbstractDGMethod</code></pre><p>This contains the necessary information for a discontinuous Galerkin method for balance laws.</p><p>See also: Outer constructor <a href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>grid</code></p><p>computational grid / mesh</p></li><li><p><code>nstate</code></p><p>number of state</p></li><li><p><code>gradstates</code></p><p>tuple of states to take the gradient of</p></li><li><p><code>inviscid_flux!</code></p><p>physical inviscid flux function</p></li><li><p><code>inviscid_numerical_flux!</code></p><p>inviscid numerical flux function</p></li><li><p><code>inviscid_numerical_boundary_flux!</code></p><p>inviscid numerical boundary flux function</p></li><li><p><code>Qgrad</code></p><p>storage for the grad</p></li><li><p><code>auxstate</code></p><p>auxiliary state array</p></li><li><p><code>source!</code></p><p>source function</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L63-L75">source</a></section><h3><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}" href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}"><code>CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> DGBalanceLaw(; grid::DiscontinuousSpectralElementGrid, length_state_vector,
              inviscid_flux!, inviscid_numerical_flux!,
              inviscid_numerical_boundary_flux! = nothing,
              auxiliary_state_length=0,
              auxiliary_state_initialization! = nothing,
              source! = nothing)</code></pre><p>Constructs a <code>DGBalanceLaw</code> spatial discretization type for the physics defined by <code>inviscid_flux!</code> and <code>source!</code>. The computational domain is defined by <code>grid</code>. The number of state variables is defined by <code>length_state_vector</code>. The user may also specify an auxiliary state which will be unpacked by the compute kernel passed on to the user-defined flux and numerical flux functions. The source function <code>source!</code> is optional.</p><p>The inviscid flux function is called with data from a degree of freedom (DOF) as</p><pre><code class="language-none">inviscid_flux!(F, Q, aux, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MArray</code> of size <code>(dim, length_state_vector)</code> to be filled (note that this is uninitialized so the user must set to zero if is this desired)</li><li><code>Q</code> is the state to evaluate (<code>MArray</code>)</li><li><code>aux</code> is the user-defined auxiliary state (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>Warning: Modifications to <code>Q</code> or <code>aux</code> may cause side effects and should be avoided.</p><p>The inviscid numerical flux function is called with data from two DOFs as</p><pre><code class="language-none">inviscid_numerical_flux!(F, nM, QM, auxM, QP, auxP, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MArray</code> of size <code>(dim, length_state_vector)</code> to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero if is this desired)</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>)</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>Warning: Modifications to <code>nM</code>, <code>QM</code>, <code>auxM</code>, <code>QP</code>, or <code>auxP</code> may cause side effects and should be avoided.</p><p>If <code>grid.topology</code> has a boundary then the function <code>inviscid_numerical_boundary_flux!</code> must be specified. This function is called with the data from the neighbouring DOF as</p><pre><code class="language-none">inviscid_numerical_boundary_flux!(F, nM, QM, auxM, QP, auxP, bctype, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MArray</code> of size <code>(dim, length_state_vector)</code> to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero is this desired)</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>)</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>bctype</code> is the boundary condition flag for the connected face and element of  <code>grid.elemtobndy</code></li><li><code>t</code> is the current simulation time</li></ul><p>Note: <code>QP</code> and <code>auxP</code> are filled with values based on degrees of freedom referenced in <code>grid.vmapP</code>; <code>QP</code> and <code>auxP</code> may be modified by the calling function.</p><p>Warning: Modifications to <code>nM</code>, <code>QM</code>, or <code>auxM</code> may cause side effects and should be avoided.</p><p>If present the source function is called with data from a DOF as</p><pre><code class="language-none">source!(S, Q, aux, t)</code></pre><p>where <code>S</code> is an <code>MVector</code> of length <code>length_state_vector</code> to be filled; other arguments are the same as <code>inviscid_flux!</code> and the same warning concerning <code>Q</code> and <code>aux</code> applies.</p><p>When <code>auxiliary_state_initialization! !== nothing</code> then this is called on the auxiliary state (assuming <code>auxiliary_state_length &gt; 0</code>) as</p><pre><code class="language-none">auxiliary_state_initialization!(aux, x, y, z)</code></pre><p>where <code>aux</code> is an <code>MArray</code> to fill with the auxiliary state for a DOF located at Cartesian coordinate locations <code>(x, y, z)</code>; see also <a href="#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!"><code>grad_auxiliary_state!</code></a> allows the user to take the gradient of a field stored in the auxiliary state.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>(x, y, z)</code>, or data derived from this such as spherical coordinates, is needed in the flux or source the user is responsible to storing this in the auxiliary state</p></div></div><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><ul><li>support viscous fluxes (<code>gradstates</code> is in the argument list as part of this future interface)</li><li>Revisit how to handle plus side state in <code>inviscid_numerical_boundary_flux!</code> after gradient state is handled (how to or not propagate changes without adverse side effects).</li></ul></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L105-L205">source</a></section><h3><a class="nav-anchor" id="Functions-2" href="#Functions-2">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.writevtk" href="#CLIMA.DGBalanceLawDiscretizations.writevtk"><code>CLIMA.DGBalanceLawDiscretizations.writevtk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writevtk(prefix, Q::MPIStateArray, disc::DGBalanceLaw [, fieldnames])</code></pre><p>Write a vtk file for all the fields in the state array <code>Q</code> using geometry and connectivity information from <code>disc.grid</code>. The filename will start with <code>prefix</code> which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings <code>fieldnames</code>; if not specified the fields names will be <code>&quot;Q1&quot;</code> through <code>&quot;Qk&quot;</code> where <code>k</code> is the number of states in <code>Q</code>, i.e., <code>k = size(Q,2)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L388-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.writevtk_helper" href="#CLIMA.DGBalanceLawDiscretizations.writevtk_helper"><code>CLIMA.DGBalanceLawDiscretizations.writevtk_helper</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">writevtk_helper(prefix, vgeo::Array, Q::Array, grid, fieldnames)</code></pre><p>Internal helper function for <code>writevtk</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L408-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!" href="#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!"><code>CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">grad_auxiliary_state!(disc, i, (ix, iy, iz))</code></pre><p>Computes the gradient of a the field <code>i</code> of the constant auxiliary state of <code>disc</code> and stores the <code>x, y, z</code> compoment in fields <code>ix, iy, iz</code> of constant auxiliary state.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This only computes the element gradient not a DG gradient. If your constant auxiliary state is discontinuous this may or may not be what you want!</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L510-L521">source</a></section><h3><a class="nav-anchor" id="Pirated-Type-Functions-1" href="#Pirated-Type-Functions-1">Pirated Type Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}" href="#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}"><code>CLIMA.MPIStateArrays.MPIStateArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MPIStateArray(disc::DGBalanceLaw; commtag=888)</code></pre><p>Given a discretization <code>disc</code> constructs an <code>MPIStateArrays</code> for holding a solution state. The optional <code>commtag</code> allows the user to set the tag to use for communication with this <code>MPIStateArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L270-L276">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}" href="#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}"><code>CLIMA.MPIStateArrays.MPIStateArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MPIStateArray(disc::DGBalanceLaw, initialization!::Function; commtag=888)</code></pre><p>Given a discretization <code>disc</code> constructs an <code>MPIStateArrays</code> for holding a solution state. The optional <code>commtag</code> allows the user to set the tag to use for communication with this <code>MPIStateArray</code>.</p><p>After allocation the <code>MPIStateArray</code> is initialized using the function <code>initialization!</code> which will be called as:</p><pre><code class="language-none">initialization!(Q, x, y, z, [aux])</code></pre><p>where <code>Q</code> is an <code>MArray</code> with the solution state at a single degree of freedom (DOF) to initialize and <code>(x,y,z)</code> is the coordinate point for the allocation. If <code>disc</code> contains an auxiliary data the values of this at the DOF are passed through as an <code>MArray</code> through the <code>aux</code> argument</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>Q</code> is <code>undef</code> at start the function (i.e., not initialized to zero)</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Modifications of the <code>aux</code> array will be discarded.</p></div></div><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>GPUify this function to remove <code>host</code> and <code>device</code> data transfers</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations.jl#L299-L328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.odefun!-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Any,Any,Any}" href="#CLIMA.SpaceMethods.odefun!-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Any,Any,Any}"><code>CLIMA.SpaceMethods.odefun!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">odefun!(disc::AbstractSpaceMethod, dQ, Q, t)</code></pre><p>Evaluates the right-hand side of the spatial discretization defined by <code>disc</code> at time <code>t</code> with state <code>Q</code>. The result is added into <code>dQ</code>. Namely, the semi-discretization is of the form <span>$Q̇ = F(Q, t)$</span> and after the call <code>dQ += F(Q, t)</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>There is no generic implementation of this function. This must be implemented for each subtype of <code>AbstractSpaceMethod</code></p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/SpaceMethods.jl#L19-L34">source</a></section><h3><a class="nav-anchor" id="Kernels-1" href="#Kernels-1">Kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.volumerhs!" href="#CLIMA.DGBalanceLawDiscretizations.volumerhs!"><code>CLIMA.DGBalanceLawDiscretizations.volumerhs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">volumerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{ngradstate},
           ::Val{nauxstate}, flux!, source!, rhs::Array, Q, Qgrad, auxstate,
           vgeo, t, D, elems) where {dim, N, nstate, ngradstate,</code></pre><p>Computational kernel: Evaluate the volume integrals on right-hand side of a <code>DGBalanceLaw</code> semi-discretization.</p><p>See <a href="#CLIMA.SpaceMethods.odefun!"><code>odefun!</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.facerhs!" href="#CLIMA.DGBalanceLawDiscretizations.facerhs!"><code>CLIMA.DGBalanceLawDiscretizations.facerhs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">facerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{ngradstate},
         ::Val{nauxstate}, inviscid_numerical_flux!,
         inviscid_numerical_boundary_flux!, rhs::Array, Q, Qgrad, auxstate,
         vgeo, sgeo, t, vmapM, vmapP, elemtobndy,
         elems) where {dim, N, nstate, ngradstate, nauxstate}</code></pre><p>Computational kernel: Evaluate the surface integrals on right-hand side of a <code>DGBalanceLaw</code> semi-discretization.</p><p>See <a href="#CLIMA.SpaceMethods.odefun!"><code>odefun!</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L105-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.initauxstate!" href="#CLIMA.DGBalanceLawDiscretizations.initauxstate!"><code>CLIMA.DGBalanceLawDiscretizations.initauxstate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">initauxstate!(::Val{dim}, ::Val{N}, ::Val{nauxstate}, auxstatefun!,
              auxstate, vgeo, elems) where {dim, N, nauxstate}</code></pre><p>Computational kernel: Initialize the auxiliary state</p><p>See <a href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L207-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.elem_grad_field!" href="#CLIMA.DGBalanceLawDiscretizations.elem_grad_field!"><code>CLIMA.DGBalanceLawDiscretizations.elem_grad_field!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">elem_grad_field!(::Val{dim}, ::Val{N}, ::Val{nstate}, Q, vgeo, D, elems, s,
                 sx, sy, sz) where {dim, N, nstate}</code></pre><p>Computational kernel: Compute the element gradient of state <code>s</code> of <code>Q</code> and store it in <code>sx</code>, <code>sy</code>, and <code>sz</code> of <code>Q</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This does not compute a DG gradient, but only over the element. If <span>$Q_s$</span> is discontinuous you may want to consider another approach.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/DGBalanceLawDiscretizations_kernels.jl#L250-L262">source</a></section><h2><a class="nav-anchor" id="DGBalanceLawDiscretizations.NumericalFluxes-1" href="#DGBalanceLawDiscretizations.NumericalFluxes-1"><code>DGBalanceLawDiscretizations.NumericalFluxes</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!" href="#CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!"><code>CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rusanov!(F::MArray, nM, QM, auxM, QP, auxP, t, flux!, wavespeed,
         [preflux = (_...) -&gt; (), correctQ!])</code></pre><p>Calculate the Rusanov (aka local Lax-Friedrichs) numerical flux given the plus and minus side states <code>QP</code> and <code>QM</code> using the physical flux function <code>flux!</code> and <code>wavespeed</code> calculation.</p><p>The <code>flux!</code> has almost the same calling convention as <code>inviscid_flux!</code> from <a href="@ref"><code>DGBalanceLaw</code></a> except that <code>preflux(Q, aux, t)</code> is splatted at the end of the call.</p><p>The function <code>wavespeed</code> should return the maximum wavespeed for a state and is called as <code>wavespeed(nM, QM, auxM, t, preflux(QM, auxM, t)...)</code> and <code>wavespeed(nM, QP, auxP, t, preflux(QP, auxP, t)...)</code> where <code>nM</code> is the outward unit normal for the minus side.</p><p>When present <code>correctQ!(QM, auxM)</code> and <code>correctQ!(QP, auxP)</code> will be after <code>wavespeed</code> and <code>flux!</code> are called to the user can modify <code>QM</code> and <code>QP</code> before <code>QM - QP</code> is needed; this is useful for correcting <code>Q</code> to include discontinuous reference states.</p><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>We may want to switch to a <code>computed_jump!</code> instead of <code>correctQ!</code> since this would allow the user to better handle round-off error with large background states.</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The undocumented arguments <code>PM</code> and <code>PP</code> for the function should not be used by external callers and are used only internally by the function <code>rusanov_boundary_flux!</code></p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/ae58f5de0a89b0ee1afac6805b0fdb6911d0fadb/src/DGmethods/NumericalFluxes.jl#L4-L38">source</a></section><footer><hr/><a class="previous" href="../Arrays/"><span class="direction">Previous</span><span class="title">Arrays</span></a><a class="next" href="../CodingConventions/"><span class="direction">Next</span><span class="title">Coding Conventions</span></a></footer></article></body></html>

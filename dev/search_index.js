var documenterSearchIndex = {"docs":
[{"location":"#CLIMA-1","page":"Home","title":"CLIMA","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Climate Machine","category":"page"},{"location":"Utilities/RootSolvers/#RootSolvers-1","page":"RootSolvers","title":"RootSolvers","text":"","category":"section"},{"location":"Utilities/RootSolvers/#","page":"RootSolvers","title":"RootSolvers","text":"CurrentModule = CLIMA.RootSolvers","category":"page"},{"location":"Utilities/RootSolvers/#","page":"RootSolvers","title":"RootSolvers","text":"RootSolvers\nfind_zero","category":"page"},{"location":"Utilities/RootSolvers/#CLIMA.RootSolvers","page":"RootSolvers","title":"CLIMA.RootSolvers","text":"RootSolvers\n\nModule containing functions for solving roots of non-linear equations. See find_zero.\n\nExample\n\nusing CLIMA.Utilities.RootSolvers\n\nx_root, converged = find_zero(x -> x^2 - 100^2, 0.0, 1000.0, SecantMethod())\n\n\n\n\n\n","category":"module"},{"location":"Utilities/RootSolvers/#CLIMA.RootSolvers.find_zero","page":"RootSolvers","title":"CLIMA.RootSolvers.find_zero","text":"x, converged = find_zero(f, x0[, x1], method;\n                         xatol=0, xrtol=sqrt(eps(eltype(x0))), \n                         yatol=sqrt(eps(eltype(x0))), maxiters=10_000)\n\nFinds the nearest root of f to x0 and x1. Returns a the value of the root x such that f(x) ≈ 0, and a Boolean value converged indicating convergence.\n\nmethod can be one of:\n\nSecantMethod(): Secant method\nRegulaFalsiMethod(): Regula Falsi method.\nNewtonsMethod(): Newton's method\nThe x1 argument is omitted for Newton's method.\n\nThe keyword arguments:\n\nxatol is the absolute tolerance of the input.\nmaxiters is the maximum number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#MoistThermodynamics-Module-1","page":"MoistThermodynamics","title":"MoistThermodynamics Module","text":"","category":"section"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"The MoistThermodynamics module provides all thermodynamic functions needed for the atmosphere and functions shared across model components. The functions are general for a moist atmosphere that includes suspended cloud condensate in the working fluid; the special case of a dry atmosphere is obtained for zero specific humidities (or simply by omitting the optional specific humidity arguments in the functions that are needed for a dry atmosphere). The general formulation assumes that there are tracers for the total water specific humidity q_tot, the liquid specific humidity q_liq, and the ice specific humidity q_ice to characterize the thermodynamic state and composition of moist air.","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"There are several types of functions:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Equation of state (ideal gas law):\nair_pressure\nSpecific gas constant and isobaric and isochoric specific heats of moist air:\ngas_constant_air\ncp_m\ncv_m\nSpecific latent heats of vaporization, fusion, and sublimation:\nlatent_heat_vapor\nlatent_heat_fusion\nlatent_heat_sublim\nSaturation vapor pressure and specific humidity over liquid and ice:\nsat_vapor_press_liquid\nsat_vapor_press_ice\nsat_shum\nFunctions computing energies and inverting them to obtain temperatures\ntotal_energy\ninternal_energy\nair_temperature\nFunctions to compute temperatures and partitioning of water into phases in thermodynamic equilibrium (when Gibbs' phase rule implies that the entire thermodynamic state of moist air, including the liquid and ice specific humidities, can be calculated from the 3 thermodynamic state variables, such as energy, pressure, and total specific humidity)\nliquid_fraction_equil (fraction of condensate that is liquid)\nsaturation_adjustment (compute temperature from energy, density, and total specific humidity)\nAuxiliary functions for diagnostic purposes, e.g., other thermodynamic quantities\nliquid_ice_pottemp (liquid-ice potential temperature)","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"A moist dynamical core that assumes equilibrium thermodynamics can be obtained from a dry dynamical core with total energy as a prognostic variable by including a tracer for the total specific humidity q_tot, using the functions, e.g., for the energies in the module, and computing the temperature T and the liquid and ice specific humidities (q.liq and q.ice) from the internal energy e_int by saturation adjustment:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"T = saturation_adjustment(e_int, ρ, q_tot);\nq = PhasePartition_equil(T, ρ, q_tot);","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"here, ρ is the density of the moist air, and the internal energy e_int = e_tot - e_kin - geopotential is the total energy e_tot minus kinetic energy e_kin and potential energy geopotential (all energies per unit mass). No changes to the \"right-hand sides\" of the dynamical equations are needed for a moist dynamical core that supports clouds, as long as they do not precipitate. Additional source-sink terms arise from precipitation.","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Schematically, the workflow in such a core would look as follows:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"# initialize\ngeopotential = grav * z\nq_tot          = ...\nρ            = ...\n\n(u, v, w)    = ...\ne_kin           = 0.5 * (u^2 + v^2 + w^2)\n\ne_tot        = total_energy(e_kin, geopotential, T, q_tot)\n\ndo timestep   # timestepping loop\n\n  # advance dynamical variables by a timestep (temperature typically\n  # appears in terms on the rhs, such as radiative transfer)\n  advance(u, v, w, ρ, e_tot, q_tot)\n\n  # compute internal energy from dynamic variables\n  e_int = e_tot - 0.5 * (u^2 + v^2 + w^2) - geopotential\n\n  # compute temperature, pressure and condensate specific humidities,\n  T = saturation_adjustment(e_int, ρ, q_tot);\n  q = PhasePartition_equil(T, ρ, q_tot);\n  p = air_pressure(T, ρ, q)\n\nend","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"For a dynamical core that additionally uses the liquid and ice specific humidities q.liq and q.ice as prognostic variables, and thus explicitly allows the presence of non-equilibrium phases such as supercooled water, the saturation adjustment in the above workflow is replaced by a direct calculation of temperature and pressure:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"T = air_temperature(e_int, q)\np = air_pressure(T, ρ, q)","category":"page"},{"location":"Utilities/MoistThermodynamics/#Functions-1","page":"MoistThermodynamics","title":"Functions","text":"","category":"section"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"CurrentModule = CLIMA.MoistThermodynamics","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"PhasePartition\nPhasePartition_equil\nThermodynamicState\nPhaseEquil\nPhaseNonEquil\nLiquidIcePotTempSHumEquil","category":"page"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.PhasePartition","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhasePartition","text":"PhasePartition\n\nRepresents the mass fractions of the moist air mixture.\n\nConstructors\n\nPhasePartition(q_tot::Real[, q_liq::Real[, q_ice::Real]])\nPhasePartition(ts::ThermodynamicState)\n\nSee also PhasePartition_equil\n\nFields\n\ntot\ntotal specific humidity\nliq\nliquid water specific humidity (default: 0)\nice\nice specific humidity (default: 0)\n\n\n\n\n\n","category":"type"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.PhasePartition_equil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhasePartition_equil","text":"PhasePartition_equil(T, ρ, q_tot)\n\nPartition the phases in equilibrium, returning a PhasePartition object using the liquid_fraction_equil function where\n\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\nThe residual q.tot - q.liq - q.ice is the vapor specific humidity.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.ThermodynamicState","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.ThermodynamicState","text":"ThermodynamicState{DT}\n\nA thermodynamic state, which can be initialized for various thermodynamic formulations (via its sub-types). All ThermodynamicState's have access to functions to compute all other thermodynamic properties.\n\n\n\n\n\n","category":"type"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.PhaseEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhaseEquil","text":"PhaseEquil{DT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic equilibrium (therefore, saturation adjustment is needed).\n\nConstructors\n\nPhaseEquil(e_int, q_tot, ρ)\n\nFields\n\ne_int\ninternal energy\nq_tot\ntotal specific humidity\ndensity\ndensity of air (potentially moist)\nT\ntemperature: computed via saturation_adjustment\n\n\n\n\n\n","category":"type"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.PhaseNonEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.PhaseNonEquil","text":"PhaseNonEquil{DT} <: ThermodynamicState\n\nA thermodynamic state assuming thermodynamic non-equilibrium (therefore, temperature can be computed directly).\n\nConstructors\n\nPhaseNonEquil(e_int, q::PhasePartition, ρ)\n\nFields\n\ne_int\ninternal energy\nq\nphase partition\ndensity\ndensity of air (potentially moist)\n\n\n\n\n\n","category":"type"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.LiquidIcePotTempSHumEquil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.LiquidIcePotTempSHumEquil","text":"LiquidIcePotTempSHumEquil(θ_liq_ice, q_tot, ρ, p)\n\nConstructs a PhaseEquil thermodynamic state from liquid-ice potential temperature.\n\nθ_liq_ice - liquid-ice potential temperature\nq_tot - total specific humidity\nρ - density\np - pressure\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"air_density\nair_pressure\nair_temperature\nair_temperature_from_liquid_ice_pottemp\ncp_m\ncv_m\ndry_pottemp\nexner\ngas_constant_air\nIce\ninternal_energy\ninternal_energy_sat\nlatent_heat_fusion\nlatent_heat_sublim\nlatent_heat_vapor\nLiquid\nliquid_fraction_equil\nliquid_fraction_nonequil\nliquid_ice_pottemp\nliquid_ice_pottemp_sat\nmoist_gas_constants\nsaturation_adjustment\nsaturation_excess\nsaturation_shum\nsaturation_shum_generic\nsaturation_vapor_pressure\nsoundspeed_air\nspecific_volume\ntotal_energy\nvirtual_pottemp","category":"page"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.air_density","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_density","text":"air_density(T, p[, q::PhasePartition])\n\nThe (moist-)air density from the equation of state (ideal gas law) where\n\nT air temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nair_density(ts::ThermodynamicState)\n\nThe (moist-)air density from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.air_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_pressure","text":"air_pressure(T, ρ[, q::PhasePartition])\n\nThe air pressure from the equation of state (ideal gas law) where:\n\nT air temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nair_pressure(ts::ThermodynamicState)\n\nThe air pressure from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.air_temperature","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_temperature","text":"air_temperature(e_int, q::PhasePartition)\n\nThe air temperature, where\n\ne_int internal energy per unit mass\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nair_temperature(ts::ThermodynamicState)\n\nThe air temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.air_temperature_from_liquid_ice_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_temperature_from_liquid_ice_pottemp","text":"air_temperature_from_liquid_ice_pottemp(θ_liq_ice, p[, q::PhasePartition])\n\nThe air temperature, where\n\nθ_liq_ice liquid-ice potential temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.cp_m","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.cp_m","text":"cp_m([q::PhasePartition])\n\nThe isobaric specific heat capacity of moist air where, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ncp_m(ts::ThermodynamicState)\n\nThe isobaric specific heat capacity of moist air, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.cv_m","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.cv_m","text":"cv_m([q::PhasePartition])\n\nThe isochoric specific heat capacity of moist air where optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ncv_m(ts::ThermodynamicState)\n\nThe isochoric specific heat capacity of moist air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.dry_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.dry_pottemp","text":"dry_pottemp(T, p[, q::PhasePartition])\n\nThe dry potential temperature where\n\nT temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\n\n\ndry_pottemp(ts::ThermodynamicState)\n\nThe dry potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.exner","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.exner","text":"exner(p[, q::PhasePartition])\n\nCompute the Exner function where\n\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nexner(ts::ThermodynamicState)\n\nCompute the Exner function, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.gas_constant_air","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.gas_constant_air","text":"gas_constant_air([q::PhasePartition])\n\nThe specific gas constant of moist air given\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ngas_constant_air(ts::ThermodynamicState)\n\nThe specific gas constant of moist air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.Ice","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.Ice","text":"Ice <: Phase\n\nAn ice phase, to dispatch over saturation_vapor_pressure and saturation_shum_generic.\n\n\n\n\n\n","category":"type"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.internal_energy","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.internal_energy","text":"internal_energy(T[, q::PhasePartition])\n\nThe internal energy per unit mass, given a thermodynamic state ts or\n\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ninternal_energy(ts::ThermodynamicState)\n\nThe internal energy per unit mass, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.internal_energy_sat","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.internal_energy_sat","text":"internal_energy_sat(T, ρ, q_tot)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation where\n\nT temperature\nρ (moist-)air density\nq_tot total specific humidity\n\n\n\n\n\ninternal_energy_sat(ts::ThermodynamicState)\n\nThe internal energy per unit mass in thermodynamic equilibrium at saturation, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.latent_heat_fusion","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_fusion","text":"latent_heat_fusion(T)\n\nThe specific latent heat of fusion where\n\nT temperature\n\n\n\n\n\nlatent_heat_fusion(ts::ThermodynamicState)\n\nThe specific latent heat of fusion given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.latent_heat_sublim","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_sublim","text":"latent_heat_sublim(T::Real)\n\nThe specific latent heat of sublimation where\n\nT temperature\n\n\n\n\n\nlatent_heat_sublim(ts::ThermodynamicState)\n\nThe specific latent heat of sublimation given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.latent_heat_vapor","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_vapor","text":"latent_heat_vapor(T::Real)\n\nThe specific latent heat of vaporization where\n\nT temperature\n\n\n\n\n\nlatent_heat_vapor(ts::ThermodynamicState)\n\nThe specific latent heat of vaporization given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.Liquid","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.Liquid","text":"Liquid <: Phase\n\nA liquid phase, to dispatch over saturation_vapor_pressure and saturation_shum_generic.\n\n\n\n\n\n","category":"type"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.liquid_fraction_equil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_fraction_equil","text":"liquid_fraction_equil(T[, q::PhasePartition])\n\nThe fraction of condensate, assuming phase equilibrium, that is liquid where\n\nT temperature\nq PhasePartition\n\nIf q.liq or q.ice are nonzero, the liquid fraction is computed from them.\n\nOtherwise, the fraction of liquid is a function that is 1 above T_freeze and goes to zero below T_freeze.\n\n\n\n\n\nliquid_fraction_equil(ts::ThermodynamicState)\n\nThe fraction of condensate that is liquid given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.liquid_fraction_nonequil","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_fraction_nonequil","text":"liquid_fraction_nonequil(T[, q::PhasePartition])\n\nThe fraction of condensate, assuming phase non-equilibrium, that is liquid where\n\nT temperature\nq PhasePartition\n\nIf q.liq or q.ice are nonzero, the liquid fraction is computed from them.\n\nOtherwise, the fraction of liquid is a function that is 1 above T_freeze and goes to zero below T_freeze.\n\ntodo: Todo\nCurrently liquid_fraction_nonequil calls liquid_fraction_equil, but we should implement a more general function here.\n\n\n\n\n\nliquid_fraction_nonequil(ts::ThermodynamicState)\n\nThe fraction of condensate that is liquid given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.liquid_ice_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_ice_pottemp","text":"liquid_ice_pottemp(T, p, q::PhasePartition)\n\nThe liquid-ice potential temperature where\n\nT temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nliquid_ice_pottemp(ts::ThermodynamicState)\n\nThe liquid-ice potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.liquid_ice_pottemp_sat","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_ice_pottemp_sat","text":"liquid_ice_pottemp_sat(T, p[, q::PhasePartition])\n\nThe saturated liquid ice potential temperature where\n\nT temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nliquid_ice_pottemp_sat(ts::ThermodynamicState)\n\nThe liquid potential temperature given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.moist_gas_constants","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.moist_gas_constants","text":"(R_m, cp_m, cv_m, γ_m) = moist_gas_constants([q::PhasePartition])\n\nWrapper to compute all gas constants at once, where optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\nThe function returns a tuple of\n\nR_m gas_constant_air\ncp_m cp_m\ncv_m cv_m\nγ_m = cp_m/cv_m\n\nWithout the specific humidity arguments, the results are that of dry air.\n\n\n\n\n\n(R_m, cp_m, cv_m, γ_m) = moist_gas_constants(ts::ThermodynamicState)\n\nWrapper to compute all gas constants at once, given a thermodynamic state ts.\n\nThe function returns a tuple of\n\nR_m gas_constant_air\ncp_m cp_m\ncv_m cv_m\nγ_m = cp_m/cv_m\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_adjustment","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_adjustment","text":"saturation_adjustment(e_int, ρ, q_tot)\n\nCompute the temperature that is consistent with\n\ne_int internal energy\nρ (moist-)air density\nq_tot total specific humidity\n\nSee also saturation_adjustment_q_t_θ_l.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_excess","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_excess","text":"saturation_excess(T, ρ, q::PhasePartition)\n\nThe saturation excess in equilibrium where\n\nT temperature\nρ (moist-)air density\nq PhasePartition\n\nThe saturation excess is the difference between the total specific humidity q.tot and the saturation specific humidity in equilibrium, and it is defined to be nonzero only if this difference is positive.\n\n\n\n\n\nsaturation_excess(ts::ThermodynamicState)\n\nCompute the saturation excess in equilibrium, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_shum","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_shum","text":"saturation_shum(T, ρ[, q::PhasePartition])\n\nCompute the saturation specific humidity, given\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nq PhasePartition\n\nIf the phase partition q is given, the saturation specific humidity is that over a mixture of liquid and ice, computed in a thermodynamically consistent way from the weighted sum of the latent heats of the respective phase transitions (Pressel et al., JAMES, 2015).  That is, the saturation vapor pressure and from it the saturation specific humidity are computed from a weighted mean of the latent heats of vaporization and sublimation, with the weights given by the fractions of condensate q.liq/(q.liq + q.ice) and q.ice/(q.liq + q.ice) that are liquid and ice, respectively.\n\nIf the condensate specific humidities q.liq and q.ice are not given or are both zero, the saturation specific humidity is that over a mixture of liquid and ice, with the fraction of liquid given by temperature dependent liquid_fraction_equil(T) and the fraction of ice by the complement 1 - liquid_fraction_equil(T).\n\n\n\n\n\nsaturation_shum(ts::ThermodynamicState)\n\nCompute the saturation specific humidity, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_shum_generic","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_shum_generic","text":"saturation_shum_generic(T, ρ[; phase=Liquid()])\n\nCompute the saturation specific humidity over a plane surface of condensate, given\n\nT temperature\nρ (moist-)air density\n\nand, optionally,\n\nLiquid() indicating condensate is liquid\nIce() indicating condensate is ice\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_vapor_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_vapor_pressure","text":"saturation_vapor_pressure(T, Liquid())\n\nReturn the saturation vapor pressure over a plane liquid surface at temperature T.\n\nsaturation_vapor_pressure(T, Ice())\n\nReturn the saturation vapor pressure over a plane ice surface at temperature T.\n\nsaturation_vapor_pressure(T, LH_0, Δcp)\n\nCompute the saturation vapor pressure over a plane surface by integration of the Clausius-Clepeyron relation.\n\nThe Clausius-Clapeyron relation\n\ndlog(p_v_sat)/dT = [LH_0 + Δcp * (T-T_0)]/(R_v*T^2)\n\nis integrated from the triple point temperature T_triple, using Kirchhoff's relation\n\nL = LH_0 + Δcp * (T - T_0)\n\nfor the specific latent heat L with constant isobaric specific heats of the phases. The linear dependence of the specific latent heat on temperature T allows analytic integration of the Clausius-Clapeyron relation to obtain the saturation vapor pressure p_v_sat as a function of the triple point pressure press_triple.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.soundspeed_air","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.soundspeed_air","text":"soundspeed_air(T[, q::PhasePartition])\n\nThe speed of sound in air, where\n\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\nWithout the specific humidity arguments, the results are that of dry air.\n\n\n\n\n\nsoundspeed_air(ts::ThermodynamicState)\n\nThe speed of sound in air given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.specific_volume","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.specific_volume","text":"specific_volume(T, p[, q::PhasePartition])\n\nThe (moist-)air specific volume from the equation of state (ideal gas law) where\n\nT air temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nspecific_volume(ts::ThermodynamicState)\n\nThe (moist-)air specific volume from the equation of state (ideal gas law), given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.total_energy","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.total_energy","text":"total_energy(e_kin, e_pot, T[, q::PhasePartition])\n\nThe total energy per unit mass, given\n\ne_kin kinetic energy per unit mass\ne_pot potential energy per unit mass\nT temperature\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\ntotal_energy(e_kin, e_pot, ts::ThermodynamicState)\n\nThe total energy per unit mass given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.virtual_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.virtual_pottemp","text":"virtual_pottemp(T, p[, q::PhasePartition])\n\nThe virtual temperature where\n\nT temperature\np pressure\n\nand, optionally,\n\nq PhasePartition. Without this argument the results are that of dry air.\n\n\n\n\n\nvirtual_pottemp(ts::ThermodynamicState)\n\nThe virtual potential temperature, given a thermodynamic state ts.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#SurfaceFluxes-1","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"CurrentModule = CLIMA.SurfaceFluxes","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Surface flux functions, e.g. for buoyancy flux, friction velocity, and exchange coefficients.","category":"page"},{"location":"Atmos/SurfaceFluxes/#Byun1990-1","page":"SurfaceFluxes","title":"Byun1990","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Compute surface fluxes using the approach in Byun (1990).","category":"page"},{"location":"Atmos/SurfaceFluxes/#Plots-1","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using CLIMA.SurfaceFluxes.Byun1990\nusing Plots, LaTeXStrings\n\nRi_range = range(-1.2, stop=0.24, length=100)\nscales = [50,200,600,1000,10_000]\n\nz_0 = 1.0\nγ_m, γ_h = 15.0, 9.0\nβ_m, β_h = 4.8, 7.8\nPr_0 = 0.74\n\nplot(Ri_range,\n    [Byun1990.compute_exchange_coefficients(Ri,scale*z_0,z_0,γ_m,γ_h,β_m,β_h,Pr_0)[1]\n        for Ri in Ri_range, scale in scales],\n    xlabel=\"Bulk Richardson number (Ri_b)\", ylabel=\"Drag coefficient\", title=\"Momentum exchange coefficient\",\n    labels=scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4a.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(a) from Byun (1990)","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"plot(Ri_range,\n    [Byun1990.compute_exchange_coefficients(Ri,scale*z_0,z_0,γ_m,γ_h,β_m,β_h,Pr_0)[2]\n        for Ri in Ri_range, scale in scales],\n    xlabel=\"Bulk Richardson number (Ri_b)\", ylabel=\"Exchange coefficient\", title=\"Heat exchange coefficient\",\n    labels=scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4b.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(b) from Byun (1990)","category":"page"},{"location":"Atmos/SurfaceFluxes/#Nishizawa2018-1","page":"SurfaceFluxes","title":"Nishizawa2018","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#Plots-2","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using CLIMA.SurfaceFluxes.Nishizawa2018\nusing Plots, LaTeXStrings\n\na = 4.7\nθ = 350\nz_0 = 10\nu_ave = 10\nflux = 1\nΔz = range(10.0, stop=100.0, length=100)\nΨ_m_tol, tol_abs, iter_max = 1e-3, 1e-3, 10\nu_star = Nishizawa2018.compute_friction_velocity.(\n    u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\nplot(u_star, Δz, title = \"Friction velocity vs dz\", xlabel = \"Friction velocity\", ylabel = \"dz\")\nsavefig(\"friction_velocity.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes/#API-1","page":"SurfaceFluxes","title":"API","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"compute_buoyancy_flux\nByun1990.compute_MO_len\nByun1990.compute_friction_velocity\nByun1990.compute_exchange_coefficients\nNishizawa2018.compute_MO_len\nNishizawa2018.compute_friction_velocity\nNishizawa2018.compute_exchange_coefficients","category":"page"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.compute_buoyancy_flux","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.compute_buoyancy_flux","text":"compute_buoyancy_flux(shf, lhf, T_b, qt_b, ql_b, qi_b, alpha0_0)\n\nComputes buoyancy flux given sensible heat flux shf, latent heat flux lhf, surface boundary temperature T_b, total specific humidity qt_b, liquid specific humidity ql_b, ice specific humidity qi_b and specific alpha0_0.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Byun1990.compute_MO_len","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_MO_len","text":"compute_MO_len(u, flux)\n\nComputes the Monin-Obukhov length (Eq. 3 Ref. Byun1990)\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Byun1990.compute_friction_velocity","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_friction_velocity","text":"compute_friction_velocity(u_ave, flux, z_0, z_1, β_m, γ_m, tol_abs, iter_max)\n\nComputes roots of friction velocity equation (Eq. 10 in Ref. Byun1990)\n\nu_ave = u_* ( ln(z/z_0) - ψ_m(z/L, z_0/L) ) /κ        Eq. 10 in Ref. Byun1990\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Byun1990.compute_exchange_coefficients","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_exchange_coefficients","text":"compute_exchange_coefficients(Ri, z_b, z_0, γ_m, γ_h, β_m, β_h, Pr_0)\n\nComputes exchange transfer coefficients:\n\nC_D  momentum exchange coefficient      (Eq. 36)\nC_H  thermodynamic exchange coefficient (Eq. 37)\nL_mo Monin-Obukhov length               (re-arranged Eq. 3)\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Nishizawa2018.compute_MO_len","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_MO_len","text":"compute_MO_len(u, θ, flux)\n\nComputes Monin-Obukhov length. Eq. 3 Ref. Nishizawa2018\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","text":"compute_friction_velocity(u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\n\nComputes friction velocity, in Eq. 12 in Ref. Nishizawa2018, by solving the non-linear equation:\n\nu_ave = ustar/κ * ( ln(Δz/z_0) - Ψ_m(Δz/L) + z_0/Δz * Ψ_m(z_0/L) + R_z0 [ψ_m(z_0/L) - 1] )\n\nwhere L is a non-linear function of ustar (see compute_MO_len).\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","text":"compute_exchange_coefficients(z, F_m, F_h, a, u_star, θ, flux, Pr)\n\nComputes exchange transfer coefficients:\n\nK_D  momentum exchange coefficient\nK_H  thermodynamic exchange coefficient\nL_mo Monin-Obukhov length\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#References-1","page":"SurfaceFluxes","title":"References","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Businger, Joost A., et al. \"Flux-profile relationships in the atmospheric surface layer.\" Journal of the atmospheric Sciences 28.2 (1971): 181-189. doi: 10.1175/1520-0469(1971)028<0181:FPRITA>2.0.CO;2\nNishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin-Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175. doi: 10.1029/2018MS001534\nByun, Daewon W. \"On the analytical solutions of flux-profile relationships for the atmospheric surface layer.\" Journal of Applied Meteorology 29.7 (1990): 652-657. doi: 10.1175/1520-0450(1990)029<0652:OTASOF>2.0.CO;2\nWyngaard, John C. \"Modeling the planetary boundary layer-Extension to the stable case.\" Boundary-Layer Meteorology 9.4 (1975): 441-460. doi: 10.1007/BF00223393","category":"page"},{"location":"Atmos/TurbulenceConvection/#TurbulenceConvection-1","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"CurrentModule = CLIMA.TurbulenceConvection","category":"page"},{"location":"Atmos/TurbulenceConvection/#Grids-1","page":"TurbulenceConvection","title":"Grids","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Grids.Grid\nGrids.over_elems\nGrids.over_elems_real\nGrids.over_elems_ghost\nGrids.first_elem_above_surface\nGrids.get_z","category":"page"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.Grid","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.Grid","text":"Grid{T}\n\nA simple 1-dimensional uniform grid of type T for finite difference method.\n\n\n\n\n\n","category":"type"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.over_elems","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.over_elems","text":"over_elems(grid::Grid)\n\nGet the range of indexes to traverse real and ghost grid elements\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.over_elems_real","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.over_elems_real","text":"over_elems_real(grid::Grid)\n\nGet the range of indexes to traverse only real grid elements\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.over_elems_ghost","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.over_elems_ghost","text":"over_elems_ghost(grid::Grid)\n\nGet the range of indexes to traverse only ghost grid elements\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.first_elem_above_surface","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.first_elem_above_surface","text":"first_elem_above_surface(grid::Grid)\n\nGet the first element index above the surface\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.get_z","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.get_z","text":"get_z(grid::Grid, k::Int)\n\nGet the z-coordinate given element index\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#Grid-Operators-1","page":"TurbulenceConvection","title":"Grid Operators","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"GridOperators.∇_z\nGridOperators.Δ_z\nGridOperators.adv_upwind","category":"page"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.GridOperators.∇_z","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.GridOperators.∇_z","text":"∇_z(f, grid::Grid)\n\nComputes the local derivative of field f: f\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.GridOperators.Δ_z","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.GridOperators.Δ_z","text":"Δ_z(f, grid::Grid)\n\nComputes the local Laplacian of field f:   (f)\n\n\n\n\n\nΔ_z(f, grid::Grid, K)\n\nComputes the local Laplacian of field f with a variable coefficient:   (K f)\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.GridOperators.adv_upwind","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.GridOperators.adv_upwind","text":"adv_upwind(ϕ, u, grid::Grid)\n\nLocal upwind advection operator u  ϕ. This operator is stable but numerically diffusive.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#State-Vector-1","page":"TurbulenceConvection","title":"State Vector","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"StateVecs.StateVec\nStateVecs.over_sub_domains\nStateVecs.Cut","category":"page"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecs.StateVec","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.StateVec","text":"StateVec{T, I, NT}\n\nA state vector containing the number of subdomains, n_subdomains, a NamedTuple variable mapper, a tuple of the variable names, and a vector of vectors, containing the values for all of the variables.\n\n\n\n\n\n","category":"type"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecs.over_sub_domains","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.over_sub_domains","text":"over_sub_domains(state_vec::StateVec)\n\nGet list of indexes from 1 to the maximum subdomain size.\n\n\n\n\n\nover_sub_domains(state_vec::StateVec, j::Int)\n\nGet list of indexes from 1 to the maximum subdomain size, except the given index.\n\n\n\n\n\nover_sub_domains(state_vec::StateVec, name::Symbol)\n\nGet list of indexes over all subdomains for variable name.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecs.Cut","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.Cut","text":"Cut{I} <: AbstractCut{I}\n\nA Cut struct used to slice the state vector along the grid-element dimension. This is used to as an API to pass Cuts into local derivative/interpolation routines.\n\n\n\n\n\n","category":"type"},{"location":"Atmos/TurbulenceConvection/#Boundary-Conditions-1","page":"TurbulenceConvection","title":"Boundary Conditions","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"BoundaryConditions.Dirichlet!\nBoundaryConditions.Neumann!\nBoundaryConditions.Top\nBoundaryConditions.Bottom","category":"page"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Dirichlet!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Dirichlet!","text":"Dirichlet!(sv::StateVec, name::Symbol, val, grid, ::Bottom, i_sd=1)\n\nApply Dirichlet boundary conditions at the bottom of the domain\n\n\n\n\n\nDirichlet!(sv::StateVec, name::Symbol, val, grid, ::Top, i_sd=1)\n\nApply Dirichlet boundary conditions at the bottom of the domain\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Neumann!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Neumann!","text":"Neumann!(sv::StateVec, name::Symbol, val, grid, ::Bottom, i_sd=1)\n\nApply Neumann boundary conditions at the bottom of the domain\n\n\n\n\n\nNeumann!(sv::StateVec, name::Symbol, val, grid, ::Top, i_sd=1)\n\nApply Neumann boundary conditions at the bottom of the domain\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Top","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Top","text":"Top<:BoundaryLocation\n\nLocation to apply boundary condition\n\n\n\n\n\n","category":"type"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Bottom","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Bottom","text":"Bottom<:BoundaryLocation\n\nLocation to apply boundary condition\n\n\n\n\n\n","category":"type"},{"location":"Atmos/TurbulenceConvection/#State-Vector-Functions-1","page":"TurbulenceConvection","title":"State Vector Functions","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"StateVecFuncs.first_elem_above_surface_val\nStateVecFuncs.surface_val\nStateVecFuncs.extrap!\nStateVecFuncs.assign_ghost!\nStateVecFuncs.domain_average!\nStateVecFuncs.distribute!\nStateVecFuncs.total_covariance!\nStateVecFuncs.export_state","category":"page"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.first_elem_above_surface_val","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.first_elem_above_surface_val","text":"first_elem_above_surface_val(sv::StateVec, name::Symbol, grid::Grid, i_sd=1)\n\nGet the value of variable name on the first element above the surface (z_min+Δz/2).\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.surface_val","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.surface_val","text":"surface_val(sv::StateVec, name::Symbol, grid::Grid, i_sd=1)\n\nGet the value of variable name on the surface (z_min) by interpolating between the first ghost point and the first element above the surface\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.extrap!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.extrap!","text":"extrap!(sv::StateVec, name::Symbol, grid::Grid, i_sd=1)\n\nExtrapolate variable name to the first ghost point.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.assign_ghost!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.assign_ghost!","text":"assign_ghost!(sv::StateVec, name::Symbol, val, grid::Grid, i_sd=1)\n\nAssign value val to variable name for all ghost points.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.domain_average!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.domain_average!","text":"domain_average!(dst::StateVec, src::StateVec, weight::StateVec\n                dst_idxs, src_idxs, weight_idx, grid::Grid)\n\nCompute the domain average in state vector dst, given state vectors src and weight, the grid grid and index iterators of source, destination and weight names src_idxs, dst_idxs, and weight_idx respectively.\n\nFormulaically, a domain-averaged variable ϕ is computed from\n\nϕ = Σ_i a_i overlineϕ_i\n\nWhere variable overlineϕ_i represents ϕ decomposed across multiple sub-domains, which are weighted by area fractions a_i.\n\nNote that domain_average! is the inverse function of distribute!.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.distribute!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.distribute!","text":"distribute!(dst::StateVec, src::StateVec, dst_idxs, src_idxs, grid::Grid)\n\nDistributes values in the state vector src, to state vectors dst given the grid grid and index iterators of source and destination names src_idxs and dst_idxs respectively.\n\nFormulaically, a domain-decomposed variable overlineϕ_i is computed from\n\noverlineϕ_i = ϕ\n\nWhere variable ϕ is the domain-averaged variable, computed across multiple sub-domains.\n\nNote that distribute! is the inverse function of domain_average!.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.total_covariance!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.total_covariance!","text":"total_covariance!(dst::StateVec, src::StateVec, cv::StateVec, weights::StateVec,\n                  dst_idxs, src_idxs, cv_idxs, weight_idx,\n                  grid::Grid, decompose_ϕ_ψ::Function)\n\nComputes the total covariance in state vector dst, given\n\nsrc source state vector\ncv state vector containing co-variances\nweights state vector containing weights\ndst_idxs indexes for destination state vector\ncv_idxs indexes for state vector containing co-variances\nweight_idx indexes for state vector containing weights\ngrid the grid\ndecompose_ϕ_ψ a function that receives the covariance index and                 returns the indexes for each variable. For example:                 :ϕ_idx, :ψ_idx = decompose_ϕ_ψ(:cv_ϕ_ψ)\n\nFormulaically, a total covariance between variables ϕ and ψ is computed from\n\nϕ^*ψ^* = Σ_i a_i overlineϕ_iψ_i + Σ_i Σ_j a_i a_j overlineϕ_i (overlineψ_i - overlineψ_j)\n\nWhere variable overlineϕ_i represents ϕ decomposed across multiple sub-domains, which are weighted by area fractions a_i.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecFuncs.export_state","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecFuncs.export_state","text":"export_state(sv::StateVec, grid::Grid, dir, filename, ::ExportType)\n\nExport StateVec to a human-readable file filename in directory dir.\n\n\n\n\n\nexport_state(sv::StateVec, dir, filename, ::ExportType = UseDat())\n\nExport StateVec to a human-readable file filename in directory dir. The z-axis is not included in the export.\n\n\n\n\n\nexport_state(sv::StateVec, grid::Grid, dir, filename, ::UseVTK)\n\nExport state vector sv to a compressed file filename in directory dir, including the z-axis, given by the grid grid.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/TurbulenceConvection/#Solving-a-diffusion-equation-1","page":"TurbulenceConvection","title":"Solving a diffusion equation","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a simple diffusion equation","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t T = K ΔT + 1 qquad T = 0  Ω","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler with StateVec and Grid constructs.","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nK = 1.0 # diffusion coefficient\nmaxiter = 1000 # time-step iterations\nΔt = 0.001 # time step\n\ngrid = Grid(0.0, 1.0, 10)\nq = StateVec(((:T, n_sd),), grid)\nrhs = deepcopy(q)\n\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    rhs[:T, k] = K*Δ_z(q[:T, Cut(k)], grid) + 1\n  end\n  for k in over_elems(grid)\n    q[:T, k] += Δt*rhs[:T, k]\n  end\n  Dirichlet!(q, :T, 0.0, grid, Top())\n  Dirichlet!(q, :T, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"T.svg\", :T) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: )","category":"page"},{"location":"Atmos/TurbulenceConvection/#Solving-a-variable-coefficient-diffusion-equation-1","page":"TurbulenceConvection","title":"Solving a variable coefficient diffusion equation","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a variable coefficient diffusion equation","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t T =   (K(z)T) + 1 qquad T = 0  Ω","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"K(z) = 1 - 9 times H(z-5) qquad H = textheaviside","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler.","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nmaxiter = 10000 # time-step iterations\nΔt = 0.001 # time step\n\ngrid = Grid(0.0, 1.0, 10)\nunknowns = ( (:T, n_sd), )\nvars = ( (:ΔT, n_sd), (:K_thermal, n_sd) )\nq = StateVec(unknowns, grid)\ntmp = StateVec(vars, grid)\nrhs = deepcopy(q)\n\ncond_thermal(z) = z > .5 ? 1 : .1\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    tmp[:K_thermal, k] = cond_thermal(get_z(grid, k))\n    tmp[:ΔT, k] = Δ_z(q[:T, Cut(k)], grid, tmp[:K_thermal, Cut(k)])\n    rhs[:T, k] = tmp[:ΔT, k] + 1\n  end\n  for k in over_elems(grid)\n    q[:T, k] += Δt*rhs[:T, k]\n  end\n  Dirichlet!(q, :T, 0.0, grid, Top())\n  Dirichlet!(q, :T, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"T_varK.svg\", :T) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: )","category":"page"},{"location":"Atmos/TurbulenceConvection/#Solving-a-linear-advection-equation-1","page":"TurbulenceConvection","title":"Solving a linear advection equation","text":"","category":"section"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Here, we solve a linear advection equation","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"_t u + cu = 0 qquad u = 0  Ω","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"u(t=0) = Gaussian(σ μ)","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"using Explicit Euler method.","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"\nusing CLIMA.TurbulenceConvection.Grids\nusing CLIMA.TurbulenceConvection.GridOperators\nusing CLIMA.TurbulenceConvection.BoundaryConditions\nusing CLIMA.TurbulenceConvection.StateVecs\nusing CLIMA.TurbulenceConvection.StateVecFuncs\nusing Plots\n\nn_sd = 1 # number of sub-domains\nmaxiter = 400 # time-step iterations\nΔt = 0.0005 # time step\n\ngrid = Grid(0.0, 1.0, 200)\nunknowns = ( (:u, n_sd), )\nvars = ( (:u_initial, n_sd), )\nq = StateVec(unknowns, grid)\ntmp = StateVec(vars, grid)\nrhs = deepcopy(q)\n\nσ, μ, c = .05, 0.3, 1.0\nT = maxiter*Δt\nic(z) = 1/(σ*sqrt(2*π))*exp(-1/2*((z-μ)/σ)^2)\nfor k in over_elems_real(grid)\n  tmp[:u_initial, k] = ic(get_z(grid, k))\n  q[:u, k] = tmp[:u_initial, k]\nend\nplot_state(tmp, grid, \"./\", \"u_initial.svg\", :u_initial) # for visualizing\nfor i in 1:maxiter\n  for k in over_elems_real(grid)\n    rhs[:u, k] = - adv_upwind(q[:u, Cut(k)], c .* [1,1,1], grid)\n  end\n  for k in over_elems(grid)\n    q[:u, k] += Δt*rhs[:u, k]\n  end\n  Dirichlet!(q, :u, 0.0, grid, Top())\n  Dirichlet!(q, :u, 0.0, grid, Bottom())\nend\nplot_state(q, grid, \"./\", \"u_final.svg\", :u) # for visualizing\nnothing # hide","category":"page"},{"location":"Atmos/TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"(Image: ) (Image: )","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"newcommandparamT1     textcolorblue  text1\nnewcommandhyperparamT1textcolororangetext1\nnewcommandsimparamT1  textcolorpurpletext1\n\nnewcommandexp1mathrmexpleft(1right)\nnewcommandatan1mathrmatanleft(1right)\nnewcommandsign1mathrmsignleft(1right)\nnewcommanderf1mathrmerfleft(1right)\nnewcommanderfinv1mathrmerfinvleft(1right)\n\nnewcommandparam1     textcolorblue  1\nnewcommandhyperparam1textcolororange1\nnewcommandsimparam1  textcolorpurple1\n\nnewcommandCROSStimes\nnewcommandGRADnabla\nnewcommandDOTbullet\nnewcommandPDpartial\nnewcommandDM1langle 1 rangle\nnewcommandiEnve\nnewcommandSD2overline1_2\nnewcommandSDi1SD1i\nnewcommandSDj1SD1j\nnewcommandSDe1SD1iEnv\nnewcommandSDiog21_2\nnewcommandSDio1SDiog1i\nnewcommandSDjo1SDiog1j\nnewcommandSDeo1SDiog1iEnv\nnewcommandaSD21_2\nnewcommandaSDi1aSD1i\nnewcommandaSDj1aSD1j\nnewcommandaSDe1aSD1iEnv\nnewcommandotherDefswhere additional variable definitions are in\n\nnewcommandIntraCVSDi2overline1_i      2_i      \nnewcommandIntraCVSDj2overline1_j      2_j      \nnewcommandIntraCVSDe2overline1_iEnv2_iEnv\n\nnewcommandInterCVSDi2overline1_i      overline2_i      \nnewcommandInterCVSDj2overline1_j      overline2_j      \nnewcommandInterCVSDe2overline1_iEnvoverline2_iEnv\n\nnewcommandTCV2langle 1^*2^* rangle\n\nnewcommandBC11_z_min\nnewcommandBCT11_z_max\nnewcommandBCB11_z_min\nnewcommandBCG11_z_boundary\n\nnewcommandWindSpeedu\nnewcommandLayerThicknessparamDelta z\nnewcommandSurfaceRoughness1paramz_01\nnewcommandSensibleSurfaceHeatFluxF_mathrmsensible\nnewcommandLatentSurfaceHeatFluxF_mathrmlatent\nnewcommandFrictionVelocityu_*\nnewcommandBuoyancyb\nnewcommandBuoyancyGradPD_z Buoyancy\nnewcommandBuoyancyFluxIntraCVSDiwtheta\nnewcommandTemperatureScaletheta_*\nnewcommandSurfaceMomentumFluxBCoverlinewu\nnewcommandSurfaceHeatFluxBCoverlinewtheta\nnewcommandSurfaceBuoyancyFluxBCIntraCVSDiwtheta\nnewcommandConvectiveVelocityw_*  Convective velocity near the surface\nnewcommandInversionHeightz_*\nnewcommandMOLenLambda_M-O\nnewcommandzLLparamz_  z at the first surface level (we should make this grid-independent)\n\nnewcommandqtq_mathrmtot\nnewcommandqlq_mathrmliq\nnewcommandqiq_mathrmice\nnewcommandqvq_mathrmvap\nnewcommandqvsatq_mathrmvap^*\nnewcommandpvsatp_mathrmvap^*\nnewcommandqcq_mathrmcon\nnewcommandThetaLtheta_mathrmliq\nnewcommandThetaVaptheta_mathrmvap\nnewcommandThetaVirttheta_mathrmvirt\nnewcommandThetaRhotheta_rho\nnewcommandThetaLiqIcetheta_mathrmliq-ice\nnewcommandThetaLiqIceSattheta^*_mathrmliq-ice\nnewcommandThetaDrytheta_mathrmdry\nnewcommandhe_mathrmint\nnewcommandhinte_mathrmint\nnewcommandhtote_mathrmtot\n\nnewcommandalphaRefalpha_0\nnewcommandrhoRefrho_0\nnewcommandpRefp_0\nnewcommandHeavisidemathcal H\n\nnewcommandalphaLLalphaRef_zLL\nnewcommanduHsimparammathbfu_h\n\nnewcommandCoriolisParamhyperparammathrmcoriolis_param\nnewcommandSubsidenceParamhyperparammathrmsubsidence\nnewcommandbetaMhyperparambeta_m\nnewcommandbetaHhyperparambeta_h\nnewcommandgammaMhyperparamgamma_m\nnewcommandgammaHhyperparamgamma_h\n\nnewcommandPTildeparamtildep\nnewcommandVKConstparamkappa_mathrmVon-Karman\nnewcommandNsdhyperparamN_sd\nnewcommandgravparamg\nnewcommandTZeroparamT_0\nnewcommandRefHintVparamhint_v0\nnewcommandRefHintIparamhint_i0\n\nnewcommandepsviparamvarepsilon_vi\nnewcommandMRatioparamM_mathrmratio\nnewcommandRdparamR_d\nnewcommandRvparamR_v\nnewcommandCp1paramc_p1\nnewcommandCv1paramc_v1\nnewcommandCvdCvd\nnewcommandCvvCvv\nnewcommandCvlCvl\nnewcommandCviCvi\n\nnewcommandDeltaCpparamDelta c_p\nnewcommandTTripleparamT_mathrmtr\nnewcommandPTripleparamp_mathrmtr\nnewcommandTFreezeparamT_mathrmfreeze\n\nnewcommandRefLHvparamL_v0\nnewcommandRefLHsparamL_s0\nnewcommandRefLHfparamL_f0\nnewcommandLatentHeatV1L_vap(1)\nnewcommandLatentHeatS1L_sub(1)\nnewcommandLatentHeatF1L_fus(1)","category":"page"},{"location":"Atmos/EDMFEquations/#Eddy-Diffusivity-Mass-Flux-(EDMF)-equations-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"This document is concerned with defining the set of equations solved in the atmospheric turbulence convection model: the EDMF equations. Color-coding is used to indicate:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"paramTConstant parameters that are fixed in space and time (eg those defined in PlanetParametersjl)\nsimparamTSingle column (SC) inputs (eg variables that are fed into the SC model from the dynamical core (eg horizontal velocity))\nhyperparamTTunable hyper-parameters that will need to be changeable but will only include single numbers (eg Float64)","category":"page"},{"location":"Atmos/EDMFEquations/#Domain-decomposition-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Domain decomposition","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"While our model is 1D along z and there is no spatial discretization in the horizontal directions (x and y), the horizontal space is broken into Nsd (sim 5-10) \"bins\", or \"subdomains\" (SDs), denoted by subscript i, where 1 le i le Nsd. One of the subdomains, the \"environment\", is treated different compared to others, termed \"updrafts\". This environment subdomain is denoted with a special index iEnv (which we usually set to 1). For dummy variables phi and psi, we use several domain and SD representations of interest:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\n  SDiphi                                                                                   quad  texthorizontal mean of variable phi over SD i \n  SDiphi = phi_i - SDiphi                                                            quad  textfluctuations of phi about the SD mean \n  IntraCVSDiphipsi                                                                      quad  textintra subdomain covariance \n  DMphi = sum_i aSDia SDiphi                                                       quad  texthorizontal mean of phi over the total domain \n  SDiphi^* = SDiphi - DMphi                                                        quad  textdifference between SD  domain means \n  InterCVSDiphipsi                                                                      quad  textinter subdomain covariance among SD means \n  phi^* = phi - DMphi                                                                    quad  textdifference between SD  domain means \n  TCVphipsi = sum_forall i a_i IntraCVSDiphipsi +\n  sum_forall i sum_forall j  aSDia aSDja SDiphi(SDipsi - SDjpsi)     quad  texttotal covariance\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, SDiphi and SDipsi are a dummy variables for the following 7 unknowns:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\n  SDiw                   quad textvertical velocity \n  SDih                  quad textinternal energy  \n  SDiqt                 quad texttotal water specific humidity  \n  SDiTKE                 quad textturbulent kinetic energy (05(IntraCVSDiuu+IntraCVSDivv+IntraCVSDiww))  \n  IntraCVSDihh       quad textintra subdomain covariance of h and h  \n  IntraCVSDiqtqt     quad textintra subdomain covariance of qt and qt \n  IntraCVSDihqt      quad textintra subdomain covariance of h and qt\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"From the large-scale model perspective, DMphi represents the resolved grid-scale (GS) mean, and TCVphipsi represents the SGS fluxes and (co)-variances of scalars that need to be parameterized. Equations in the following sections, \\eqref{eq:AreaFracGov}, \\eqref{eq:1stMoment} and \\eqref{eq:2ndMoment}, are solved on z_min le z le z_max and t ge 0. There are 8 Nsd equations in total.","category":"page"},{"location":"Atmos/EDMFEquations/#Domain-averaged-equations-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Domain averaged equations","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The EDMF model can be used in the context of a stand-alone single column, or integrated with a dynamical core. Either way, the EDMF model relies on domain-averaged variables, which may be prescribed or solved for. Taking an area fraction-weighted average of the SD equations yields the domain-averaged equations (which should be consistent with variables in the dynamical core).","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The domain-averaged equations for DMphi in w qt h uH are:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nPD_t (rhoRef DMphi)\n+ PD_z (rhoRef DMw DMphi)\n+ nabla_h DOT left( rhoRef DMphi otimes DMphi right)\n= \n  DMS_textdiff\n+ DMS_textpress\n+ DMS_textcoriolis\n+ DMS_textsubsidence\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nDMS_textdiff        = PD_z (rhoRef aSDea K_iEnv PD_z DMphi) labeleqgm_diffusion \nDMS_textpress       = - GRAD_h DMp                                       labeleqgm_pressure \nDMS_textcoriolis    = CoriolisParam DMphi CROSS mathbfk             labeleqgm_coriolis \nDMS_textsubsidence  = - SubsidenceParam GRAD phi                          labeleqgm_subsidence \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Sub-domain-equations:-Area-fraction-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Sub-domain equations: Area fraction","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The EDMF equations take the form of advection-diffusion equations. The size of these SDs are tracked by solving an equation governing the area fraction in the ith SD (aSDia), given by:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"begingather\n  PD_t (rhoRef aSDia)\n  + PD_z (rhoRef aSDia SDiw)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH)\n  =\n  SDiS^a\n   quad i = 12 Nsd labeleqAreaFracGov \n  sum_i aSDia = 1 labeleqAreaFracConserve \n  qquad 0  aSDia  1 labeleqAreaFracConstraint\nendgather","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, rhoRef SDiw uH is fluid density, mean vertical velocity along z, and domain-mean of the horizontal velocity respectively. The area fraction constraints are necessary to ensure the system of equations is well-posed. All source terms (SDiS^a) will be discussed in later sections.","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"note: Note\nThe greater than zero constraint must be satisfied at every step of the solution process, since it is necessary to avoid division by zero in the mean field equations.","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^a = SDiS_epsilondelta^a\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Source-term-definitions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source term definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"We note that the net exchange is zero sum_i SDiS_epsilondelta^a = 0. Therefore, we may define the environment source term as the negative sum of all updraft source terms. The entrainment-detrainment source is:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS_epsilondelta^a =\nbegincases\n  rho a_i SDiw left( -delta_i + sum_jne i epsilon_j right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^a  i = iEnv \nendcases\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_ij) and (delta_i).","category":"page"},{"location":"Atmos/EDMFEquations/#Sub-domain-equations:-1st-moment-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Sub-domain equations: 1st moment","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The 1st moment sub-domain equations are:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleq1stMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad i = 12 Nsd \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Atmos/EDMFEquations/#Source-terms-per-equation-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^phi =\n  SDiS_epsilondelta^phi\n+ SDiS_textturb-transp^phi quad forall phi\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^w =\n  SDiS_epsilondelta^w\n+ SDiS_textturb-transp^w\n+ SDiS_textbuoy\n+ SDiS_textnh-press\n+ SDiS_textcoriolis \nSDiS^h =\n  SDiS_epsilondelta^h\n+ SDiS_textturb-transp^h\n+ SDiS_textMP-MSS^h\n+ SDiS_textrad \nSDiS^qt =\n  SDiS_epsilondelta^qt\n+ SDiS_textturb-transp^qt\n+ SDiS_textMP-MSS^qt\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Source-term-definitions-2","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source term definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Note: The sum of the total pressure and gravity are recast into the sum of the non-hydrostatic pressure and buoyancy sources.","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS_epsilondelta^phi =\nbegincases\n  rhoRef a_i SDiw left( -delta_i SDiphi + epsilon_i SDjphi right)  i ne iEnv \n  0 - sum_j ne iEnv SDjS_epsilondelta^phi  i=iEnv \nendcases \nSDiS_textturb-transp^phi  =  -PD_z (rhoRef a_i IntraCVSDiww) \n  = PD_z (rhoRef a_i K_i^m PD_z SDiphi) \nSDiS_textnh-press = -rhoRef aSDia left( alpha_b SDib  + alpha_d frac(SDiw - SDew)  SDiw - SDew  r_d aSDia^12 right) \nalpha_b = 13 quad alpha_d = 0375 quad r_d      = 500 m \nSDiS_textbuoy = rhoRef aSDia SDib \nSDiS_textcoriolis  = f(SDimathbfu - SDimathbfu_textgeo-wind) \nSDiS_textrad  = left( PD_t SDih right)_radiation \nSDiS_textgrav = - rhoRef grav \nSDiS_textMP-MSS^qt  = \nSDiS_textMP-MSS^h  = \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_ij) and (delta_i).\nBuoyancy (Buoyancy).\nEddy diffusivity (K_i).","category":"page"},{"location":"Atmos/EDMFEquations/#Sub-domain-equations:-2nd-moment-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Sub-domain equations: 2nd moment","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The 2nd moment sub-domain equations are of the exact same form as the 1st moment equations (equation \\eqref{eq:1stMoment}):","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleq2ndMoment\n  PD_t (rhoRef aSDia SDiphi)\n  + PD_z (rhoRef aSDia SDiw SDiphi)\n  + GRAD_h DOT\n  (rhoRef aSDia DMuH SDiphi)\n  =\n  SDiS^phi\n   quad i = 12 Nsd \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, SDiS^phi are source terms, including diffusion, and many other sub-grid-scale (SGS) physics. In general, SDiS^phi and SDiS^a may depend on SDjphi and or aSDja for any j.","category":"page"},{"location":"Atmos/EDMFEquations/#Source-terms-per-equation-2","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source terms per equation","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The source terms common to all unknowns are:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\nquad forall phi psi\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Additional source terms exist in other equations:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS^TKE =\n  SDiS_epsilondelta^TKE\n+ SDiS_textx-grad flux^TKE\n+ SDiS_textturb-transp^TKE\n+ SDiS_textdissip\n+ SDiS_textpress\n+ SDiS_textbuoyancy \nSDiS^phipsi =\n  SDiS_epsilondelta^phipsi\n+ SDiS_textx-grad flux^phipsi\n+ SDiS_textturb-transp^phipsi\n+ SDiS_textMP-MSS^phipsi\nquad phipsi in qtqt hh h qt\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Source-term-definitions-3","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Source term definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiS_epsilondelta^phipsi =\nbegincases\n  rhoRef a_i SDiw left -delta_i IntraCVSDiphipsi + sum_jne iepsilon_ij\nleft(\nIntraCVSDjphipsi + (SDjphi - SDiphi)(SDjpsi - SDipsi)\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^phipsi  i=iEnv \nendcases \nSDiS_epsilondelta^TKE =\nbegincases\n  rhoRef a_i SDiw left -delta_i SDiTKE + sum_jne iepsilon_ij\nleft(\nSDjTKE + frac12 (SDjw - SDiw)^2\nright) right  i ne iEnv \n  0 - sum_jne iEnv SDjS_epsilondelta^TKE  i=iEnv \nendcases \nSDiS_textx-grad flux^phipsi\n =\n- rhoRef a_i IntraCVSDiwpsi PD_z SDiphi\n- rhoRef a_i IntraCVSDiwphi PD_z SDipsi \n =\n rhoRef a_i K_i PD_z SDipsi PD_z SDiphi \nSDiS_textx-grad flux^TKE\n =\nrhoRef a_i K_i left left(PD_zDMuright)^2 + left(PD_zDMvright)^2 + left(PD_zDMwright)^2 right \nSDiS_textturb-transp^phipsi  = - PD_z (rhoRef a_i overlinew_iphi_ipsi_i) \n = PD_z (rhoRef a_i K_i PD_z IntraCVSDiphipsi) \nSDiS_textturb-transp^TKE  = PD_z (rhoRef a_i K_i PD_z SDiTKE) \nSDiS_textdissip\n = -c_e IntraCVSDiphipsi fracSDiTKE^12SDiol_mix quad textEquation 38 in Tan et al \nc_e  = 2 \nSDiS_textpress\n = - aSDia left IntraCVSDiu(partial_x p^dagger) +\n                      IntraCVSDiv(partial_y p^dagger) +\n                      IntraCVSDiw(partial_z p^dagger)right  \n = 0 qquad textfor now need to derive correct formulation \nSDiS_textbuoyancy^TKE  = rhoRef aSDia BuoyancyFlux \nSDiS_textMP-MSSP^qtqt\n = \nSDiS_textMP-MSSP^hh\n = \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nEntrainment-Detrainment (epsilon_ij) and (delta_i).\nEddy diffusivity (K_i).\nMixing length (l_mix).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Atmos/EDMFEquations/#EDMF-variable-definitions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"EDMF variable definitions","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The following definitions are ordered in a dependency fashion; all variables are defined from variables already defined in previous subsections.","category":"page"},{"location":"Atmos/EDMFEquations/#Constants-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Constants","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nc_K  = 01 \ntexttol_InversionHeightmathrm-stable  = 001 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Reference-state-profiles-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Reference state profiles","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles are (suppressing i subscript):","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nlogpRef = loghyperparamBCpRef + frac-gravRd int_z_min^z frac1textdenom dz \ntextdenom = hyperparamBCDMT (1 - hyperparamBCDMqt + epsvi (hyperparamBCDMqt - DMql - DMqi)) \nrhoRef = fracpRefhyperparamBCT left R_d ( 1 + (MRatio - 1) hyperparamBCDMqt - MRatio (DMql + DMqi) ) right \nalphaRef = frac1rhoRef \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Specific-heats-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Specific heats","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nc_vm = (1 - SDiqt) Cvd + SDiqv Cvv + SDiql Cvl + SDiqi Cvi \nc_pm = (1 - SDiqt) Cpd + SDiqt Cpv \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Latent-heat-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Latent heat","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nLatentHeatVT = RefLHv + Cpv - Cpl (T - TTriple) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Mixing-ratios-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Mixing ratios","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMixingRatios\nr_c  = fracSDiqt+SDiql1 - SDiqt \nr_v  = fracSDiqt-SDiql-SDiqi1 - SDiqt \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Shear-production-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Shear production","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqShearProduction\nS^2 = (PD_z DMu)^2 + (PD_z DMv)^2 + (PD_z SDew)^2 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Saturation-adjustment-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Saturation adjustment","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"When assuming phase equilibrium, a non-linear equation must be solved to determine the temperature that satisfies this equilibrium. This set of equations can be solved using a standard root solver (e.g., Secant method).","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"The roots of the following system are satisfied when SDiqt  qvsat(T), otherwise SDiT = TZero + frachint(T)(1-qt)Cvd + qt Cvv + qt RefHintV.","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Knowns: SDiqt SDih rhoRef\nUnknowns: SDiT","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nhint(T) = c_vm (T - TZero)  + qv RefHintV - qi RefHintI \npvsat(T) = PTriple left( fracTTTriple right)^fracDeltaCpRv expfracRefLHv - DeltaCp TZeroRv left( frac1TTriple - frac1T right) \nqvsat = fracpvsat(T)rho Rv T \nqc = max(qt - qvsat 0) \nqv = qt - ql - qi \nql = lambda qc \nqi = (1-lambda) qc \nlambda(T) = mathcalH(T-TFreeze) quad mathcalH = textheaviside function \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Specific heats c_pm and c_vm.\nReference state profiles (pRef, rhoRef, and alphaRef).","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"This set of equations are only necessary when converting from a (ThetaLqt) formulation to our (hintqt) formulation. The roots of the following system are satisfied when SDiqt  qvsat(T), otherwise SDiql = 0 and SDiT = SDiThetaL left(fracpRefPTilderight)^fracRdCpd.","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Knowns: SDiqt SDiThetaL pRef\nUnknowns: SDiT","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nSDiThetaL = SDiT left(fracPTildepRefright)^fracR_mc_pm\nleft(1 - frac RefLHv SDiql + RefLHs SDiqic_pm SDiT right) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Specific heats c_pm and c_vm.\nReference state profiles (pRef, rhoRef, and alphaRef).","category":"page"},{"location":"Atmos/EDMFEquations/#Buoyancy-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Buoyancy","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqBuoyancy\nSDib^dagger = grav (SDialpha - alphaRef)alphaRef \nSDib = SDib^dagger - sum_j a_j SDjb^dagger \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).","category":"page"},{"location":"Atmos/EDMFEquations/#Potential-temperatures-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Potential temperatures","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Fix: which virtual potential temperature is used","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqTheta\nSDiThetaDry = SDiT(pRefPTilde)^-RdCpd \nSDiThetaVirt  = SDiThetaDry (1 - r_c + 061 r_v) \nSDiThetaVirt = SDitheta left(1 + 061 SDiq_r - SDiql right) \nSDiThetaRho = fracSDiT (1 - SDiqt + epsvi qv)(pRefPTilde)^paramkappa \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nMixing ratios (r_c, r_v).","category":"page"},{"location":"Atmos/EDMFEquations/#Buoyancy-gradient-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Buoyancy gradient","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Short buoyancy gradient","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqBuoyancyGrad\nBuoyancyGrad  = - fracgravDMThetaVirt PD_z SDiThetaVirt \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Long buoyancy gradient","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqBuoyancyGradLong\nBuoyancyGrad  = - PD_z SDiThetaL\nleft (1-f_c) PD_ThetaL b _d  + f_c PD_ThetaL b _s right -\nPD_z SDiqt      left (1-f_c) PD_qt b _d + f_c PD_qt b _s right \nf_c = 0 qquad textgood for simple cases need to confirm for more complex cases \nPD_ThetaL b _d  = fracgravDMThetaVirt left 1 + left( fracRvRd - 1 right) SDiqt right \nPD_ThetaL b _s = fracgravDMThetaVirt left 1 + fracRvRd left(1 + fracLatentHeatVSDiTRv SDiT right) SDiq_s - SDiqt right left( 1 + fracLatentHeatVSDiT^2paramc_p Rv SDiT^2 SDiq_s right)^-1 \nPD_qt b _d = fracgravDMThetaVirt left( fracRvRd - 1 right) SDitheta \nPD_qt b _s = left( fracLatentHeatVSDiTparamc_p SDiT PD_ThetaL b _s - fracgravDMThetaVirt right) SDitheta \nSDitheta = SDiT(pRefPTilde)^-RdCpd \nSDiq_r  = q_rain = 0 qquad textfor now \nSDiq_s  = qvsat \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nPotential temperatures (ThetaDry, ThetaVirt).\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Atmos/EDMFEquations/#Surface-fluxes-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Surface fluxes","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Variables in this section must be computed simultaneously because it requires the solution of a non-linear equation.","category":"page"},{"location":"Atmos/EDMFEquations/#Monin-Obhukov-length-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Monin-Obhukov length","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMOLen\nMOLen = begincases\n- fracFrictionVelocity^3 thetaVKConst grav SurfaceHeatFlux  SurfaceHeatFlux  0 \n0  textotherwise \nendcases \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Friction-velocity-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Friction velocity","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Knowns: u_mathrmave = sqrtDMu^2+DMv^2 LayerThickness SurfaceRoughnessm\nUnknowns: FrictionVelocity MOLen, and SurfaceMomentumFlux","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqFrictionVelocity\nu_mathrmave      = fracFrictionVelocityVKConst    left logleft(fracLayerThicknessSurfaceRoughnessmright) - Psi_mleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnessmLayerThickness Psi_mleft(fracSurfaceRoughnessmMOLenright) + R_z0m left psi_mleft(fracSurfaceRoughnessmMOLenright) - 1 right right \nR_z0m               = 1 - SurfaceRoughnesshLayerThickness \nSurfaceMomentumFlux  = -FrictionVelocity^2                 labeleqSurfaceMomentumFlux  \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where Psi_m is defined in Appendix A, equations A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Atmos/EDMFEquations/#Temperature-scale-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Temperature scale","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"NOTE: All variables (Monin-Obhukov length, friction velocity, temperature scale) in Surface fluxes must be solved simultaneously","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Knowns: theta_mathrmave theta_s LayerThickness SurfaceRoughnessh\nUnknowns: FrictionVelocity MOLen, and SurfaceHeatFlux","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqTemperatureScale\ntheta_mathrmave - theta_s  = fracPr TemperatureScaleVKConst left logleft(fracLayerThicknessSurfaceRoughnesshright) - Psi_hleft(fracLayerThicknessMOLenright) + fracSurfaceRoughnesshLayerThickness Psi_mleft(fracSurfaceRoughnesshMOLenright) + R_z0h left psi_hleft(fracSurfaceRoughnesshMOLenright) - 1 right right \nR_z0h                           = 1 - SurfaceRoughnesshLayerThickness \nSurfaceHeatFlux                  = -FrictionVelocityTemperatureScale  labeleqSurfaceHeatFlux  \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where Psi_h is defined in Appendix A, equation A6 in Nishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin‐Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175.","category":"page"},{"location":"Atmos/EDMFEquations/#Prandtl-number-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Prandtl number","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqPrandtlNumber\nPr_neut = 074 \nPr(z) = begincases\n    Pr_neut  MOLen  0 \n    Pr_neut left frac1 + omega_2 R_g - sqrt-4 R_g + (1+omega_2 R_g)^22 R_g right  textotherwise \nendcases \nomega_2 = omega_1+1 \nomega_1 = frac4013 \nR_g = fracBuoyancyGradS^2 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Shear production (S).\nMonin-Obhukov length (MOLen).\nBuoyancy gradient (BuoyancyGrad).","category":"page"},{"location":"Atmos/EDMFEquations/#Mixing-length-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Mixing length","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"note: Note\nThese mixing length have been tested for the environment, not the updrafts","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMixingLength\nSDiol_mix^m = fracsum_j l_j e^-l_jsum_j e^-l_j qquad j = 123 \nl_1 = fracsqrtc_wSDeTKESDeN \nSDeN = fracgrav PD_z SDeThetaVirtSDeThetaVirt  qquad text(buoyancy frequency of environment) \nl_2 = fracVKConst zc_K kappa^* phi_m(xi) \nxi = zMOLen \nphi_m(xi) = left( 1 + a_l fraczMOLen right)^-b_l \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nkappa^* = fracFrictionVelocitysqrtSDeTKE \nl_3 = sqrtfracc_varepsilonc_K sqrtSDeTKE\nleft S^2 - frac1Pr(z) BuoyancyGrad right^-12 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Constants.\nShear production (S).\nMonin-Obhukov length (MOLen).\nFriction velocity (FrictionVelocity).\nBuoyancy gradient (BuoyancyGrad).\nPotential temperatures (ThetaDry, ThetaVirt).\nPrandtl number (Pr).","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Smoothing function is provided in python file. The Prandtl number was used from Eq. 75 in Dan Li 2019 \"Turbulent Prandtl number in the atmospheric BL - where are we now\".","category":"page"},{"location":"Atmos/EDMFEquations/#Eddy-diffusivity-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy diffusivity","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqEddyDiffusivity\nSDiK_m  = begincases\nc_K SDiol_mix sqrtSDiTKE  i = iEnv \n0  textotherwise\nendcases \nSDiK_h  = fracSDiK_mPr \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Constants.\nMixing length (l_mix).\nPrandtl number (Pr).","category":"page"},{"location":"Atmos/EDMFEquations/#Buoyancy-flux-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Buoyancy flux","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"todo: Todo\nCurrently, BuoyancyFlux is hard-coded from the first expression (which was used in SCAMPy), however, this value should be computed from the SurfaceFluxes section.","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqBuoyancyFlux\nSurfaceBuoyancyFlux  = fracgrav BCalphaRefc_pm BCSDiT (SensibleSurfaceHeatFlux + (epsvi - 1) c_pm BCSDiT LatentSurfaceHeatFlux  LatentHeatVBCSDiT) \nBuoyancyFlux  = - K_i BuoyancyGrad \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Eddy diffusivity (K_i).\nLatent heat (LatentHeatVT).\nBuoyancy gradient (BuoyancyGrad).","category":"page"},{"location":"Atmos/EDMFEquations/#Entrainment-Detrainment-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Entrainment-Detrainment","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Entrainment (epsilon_ij)","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqEntrainment\nepsilon_ij = c_epsilon fracmax(SDib 0)SDiw^2 \nc_epsilon = 012 \nalpha_i = fracRd SDiTpRef (1 - SDiqt + epsvi SDiqv) \nSDiqv = SDiqt - SDiql - SDiqi \nSDiqi = 0 quad textmay change later \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Detrainment (delta_j):","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqDetrainment\ndelta_i = c_delta fracmin(SDib 0)SDiw^2 + delta_B mathcalH(SDiql) \nc_delta = c_delta0 + Gamma(aSDia) \nGamma(aSDia) = 0 \nc_delta0 = c_epsilon = 012 \ndelta_B = 0004 m^-1 \nmathcalH = textHeaviside function \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nSaturation adjustment Temperature (SDiT) and specific humidity of liquid (SDiql).\nBuoyancy (Buoyancy).","category":"page"},{"location":"Atmos/EDMFEquations/#Inversion-height-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Inversion height","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqInversionHeight\nSDioInversionHeight =\nbegincases\n  left (PD_z theta_rho)^-1 (BCtheta_rho - theta_rho_z_1) + z_1 right  simparamBCDMu^2 + simparamBCDMv^2 = texttol_InversionHeightmathrm-stable \n  left (PD_z Ri_bulk)^-1 (hyperparamRi_bulk crit - Ri_bulk_z_2) + z_2 right  textotherwise \nendcases \nz_1 = min_z (theta_rho(z)  BCtheta_rho) \nz_2 = min_z (Ri_bulk(z)  hyperparamRi_bulk crit) \nRi_bulk = grav z frac(theta_rhoBCtheta_rho - 1)simparamDMu^2 + simparamDMv^2 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Potential temperatures (theta).","category":"page"},{"location":"Atmos/EDMFEquations/#Convective-velocity-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Convective velocity","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqConvectiveVelocity\nSDioConvectiveVelocity = (max(BuoyancyFlux SDioInversionHeight 0))^13 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Inversion height (SDioInversionHeight).\nBuoyancy flux (BuoyancyFlux).","category":"page"},{"location":"Atmos/EDMFEquations/#Non-local-mixing-length-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Non-local mixing length","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalignlabeleqMixingLengthOld\nSDiol_mix = (l_A^-1 + l_B^-1)^-1 \nl_A = VKConst z left( 1 + a_l fraczMOLen right)^b_l \nSDiol_B = SDiotau SDiTKE \n(a_l b_l) =\nbegincases\n  (-100 02)  MOLen  0 \n  (27 -1)  textotherwise \nendcases \nSDiotau = SDioInversionHeightSDioConvectiveVelocity \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Inversion height (SDioInversionHeight).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).","category":"page"},{"location":"Atmos/EDMFEquations/#Boundary-Conditions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Boundary Conditions","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Here, we specify boundary conditions (BCs) by their type, Dirichlet (D) or Neumann (N), and their value.","category":"page"},{"location":"Atmos/EDMFEquations/#BC-functions-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"BC functions","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nGamma_phi(F_1 F_2)\n = begincases\n    4 fracF_1 F_2FrictionVelocity^2 (1 - 83zLLMOLen)^-23  MOLen  0 \n    4 fracF_1 F_2FrictionVelocity^2  textotherwise\nendcases \nGamma_TKE\n = begincases\n    375 FrictionVelocity^2 + 02 ConvectiveVelocity^2 + FrictionVelocity^2 (-zLLMOLen)^23  MOLen  0 \n    375 FrictionVelocity^2  textotherwise\nendcases \nSensibleSurfaceHeatFlux  = BCTCVwhint c_pm rhoRef \nLatentSurfaceHeatFlux    = BCTCVwqt  LatentHeatVT rhoRef \nF_hint(SensibleSurfaceHeatFlux)   = fracSensibleSurfaceHeatFluxc_pm       = BCTCVwhint rhoRef \nF_qt(LatentSurfaceHeatFlux)       = fracLatentSurfaceHeatFluxLatentHeatVT = BCTCVwqt   rhoRef \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Reference state profiles (pRef, rhoRef, and alphaRef).\nMonin-Obhukov length (MOLen).\nConvective velocity (SDioConvectiveVelocity).\nFriction velocity (FrictionVelocity).\nLatent heat (LatentHeatVT).","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"and equation \\eqref{eq:TopPercentile} represents the mean of the top x-fraction of a standard normal distribution (Neggers et al., 2009).","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nPhi^-1(x)  = textinverse cumulative distribution function labeleqInverseCDF \nmathcal D(x) = frac1sqrt2pi x exp- frac12 (Phi^-1(1-x))^2   labeleqTopPercentile \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#Area-fraction-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Area fraction","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nc_frac = 01 quad\nBCBaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases quad\nBCTaSDia =\nbegincases\n    1-c_frac  i = iEnv \n  fracc_fracNsd  i ne iEnv\nendcases\nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#st-order-moments-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"1st order moments","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Top boundary","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCTSDiw           = 0 \nPD_z BCTSDiqt   = 0 \nPD_z BCTSDihint = 0 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Bottom boundary","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCBSDiw     = 0 \n- SDiK_m PD_z BCBSDiqt   = TCVwqt   + mathcal D(aSDia) sqrtC_qt  WindSpeed^2Gamma_phi(TCVwqt   TCVwqt   ) \n- SDiK_m PD_z BCBSDihint = TCVwhint + mathcal D(aSDia) sqrtC_hintWindSpeed^2Gamma_phi(TCVwhint TCVwhint ) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"BC functions mathcal D.","category":"page"},{"location":"Atmos/EDMFEquations/#nd-order-moments-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"2nd order moments","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Top boundary","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCTSDiTKE                          = 0 \nPD_z BCTIntraCVSDiqtqt        = 0 \nPD_z BCTIntraCVSDihinthint    = 0 \nPD_z BCTIntraCVSDihintqt      = 0 \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"todo: Todo\nCurrently, we only account for the intra sub-domain covariance, but we would like to also account for the inter sub-domain covariance for all but the TKE.","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Bottom boundary","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"beginalign\nBCBSDiTKE                    = Gamma_TKE \nBCBIntraCVSDiqtqt        = Gamma_phi(TCVwqt   TCVwqt   ) \nBCBIntraCVSDihinthint    = Gamma_phi(TCVwqt   TCVwhint ) \nBCBIntraCVSDihintqt      = Gamma_phi(TCVwhint TCVwhint ) \nendalign","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"where additional variable/function definitions are in:","category":"page"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"BC functions Gamma_TKE, Gamma_phi, F_hint, SensibleSurfaceHeatFlux, F_qt, LatentSurfaceHeatFlux.","category":"page"},{"location":"Atmos/EDMFEquations/#Case-specific-configurations-1","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Case-specific configurations","text":"","category":"section"},{"location":"Atmos/EDMFEquations/#","page":"Eddy-Diffusivity Mass-Flux (EDMF) equations","title":"Eddy-Diffusivity Mass-Flux (EDMF) equations","text":"Case Variable Value Reference\nBomex BCp_s 1000 [hPa] \nBomex BCDMqt 5 [g/kg] \nBomex BCDMThetaL 300 [K] \nBomex BCTCVwqt 52 times 10^-5 m s^-1 \nBomex BCTCVwThetaL 8 times 10^-3 K m s^-1 \nSoares BCTCVwqt 25 times 10^-5 m s^-1 \nSoares BCTCVwThetaL 6 times 10^-2 K m s^-1 \n   ","category":"page"},{"location":"ODESolvers/#ODESolvers-1","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"CurrentModule = CLIMA","category":"page"},{"location":"ODESolvers/#LowStorageRungeKutta-1","page":"ODESolvers","title":"LowStorageRungeKutta","text":"","category":"section"},{"location":"ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"LowStorageRungeKuttaMethod.LowStorageRungeKutta\nLowStorageRungeKuttaMethod.updatedt!","category":"page"},{"location":"ODESolvers/#CLIMA.LowStorageRungeKuttaMethod.LowStorageRungeKutta","page":"ODESolvers","title":"CLIMA.LowStorageRungeKuttaMethod.LowStorageRungeKutta","text":"LowStorageRungeKutta(f, Q; dt, t0 = 0)\n\nThis is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function f with the state Q, i.e.,\n\nQ̇ = f(Q)\n\nwith the required time step size dt and optional initial time t0.  This time stepping object is intended to be passed to the solve! command.\n\nThis uses the fourth-order, low-storage, Runge–Kutta scheme of Carpenter and Kennedy (1994) (in their notation (5,4) 2N-Storage RK scheme).\n\nReferences\n\n@TECHREPORT{CarpenterKennedy1994,\n  author = {M.~H. Carpenter and C.~A. Kennedy},\n  title = {Fourth-order {2N-storage} {Runge-Kutta} schemes},\n  institution = {National Aeronautics and Space Administration},\n  year = {1994},\n  number = {NASA TM-109112},\n  address = {Langley Research Center, Hampton, VA},\n}\n\n\n\n\n\n","category":"type"},{"location":"ODESolvers/#CLIMA.LowStorageRungeKuttaMethod.updatedt!","page":"ODESolvers","title":"CLIMA.LowStorageRungeKuttaMethod.updatedt!","text":"updatedt!(lsrk::LowStorageRungeKutta, dt)\n\nChange the time step size to dt for `lsrk.\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers/#GenericCallbacks-1","page":"ODESolvers","title":"GenericCallbacks","text":"","category":"section"},{"location":"ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"GenericCallbacks.EveryXWallTimeSeconds\nGenericCallbacks.EveryXSimulationSteps","category":"page"},{"location":"ODESolvers/#CLIMA.GenericCallbacks.EveryXWallTimeSeconds","page":"ODESolvers","title":"CLIMA.GenericCallbacks.EveryXWallTimeSeconds","text":"EveryXWallTimeSeconds(f, time, mpicomm)\n\nThis callback will run the function 'f()' every time wallclock time seconds. The mpicomm is used to syncronize runtime across MPI ranks.\n\n\n\n\n\n","category":"type"},{"location":"ODESolvers/#CLIMA.GenericCallbacks.EveryXSimulationSteps","page":"ODESolvers","title":"CLIMA.GenericCallbacks.EveryXSimulationSteps","text":"EveryXSimulationSteps(f, steps)\n\nThis callback will run the function 'f()' every steps of the time stepper\n\n\n\n\n\n","category":"type"},{"location":"ODESolvers/#ODESolvers-2","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.solve!\nODESolvers.gettime","category":"page"},{"location":"ODESolvers/#CLIMA.ODESolvers.solve!","page":"ODESolvers","title":"CLIMA.ODESolvers.solve!","text":"solve!(Q, solver::AbstractODESolver; timeend,\n       stopaftertimeend=true, numberofsteps, callbacks)\n\nSolves an ODE using the solver starting from a state Q. The state Q is updated inplace. The final time timeend or numberofsteps must be specified.\n\nA series of optional callback functions can be specified using the tuple callbacks; see GenericCallbacks.\n\n\n\n\n\n","category":"function"},{"location":"ODESolvers/#CLIMA.ODESolvers.gettime","page":"ODESolvers","title":"CLIMA.ODESolvers.gettime","text":"gettime(solver::AbstractODESolver)\n\nReturns the current simulation time of the ODE solver solver\n\n\n\n\n\n","category":"function"},{"location":"Mesh/#Meshing-Stuff-1","page":"Mesh","title":"Meshing Stuff","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"CurrentModule = CLIMA","category":"page"},{"location":"Mesh/#Topologies-1","page":"Mesh","title":"Topologies","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.","category":"page"},{"location":"Mesh/#Types-1","page":"Mesh","title":"Types","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Topologies.AbstractTopology\nTopologies.BoxElementTopology\nTopologies.BrickTopology\nTopologies.StackedBrickTopology\nTopologies.CubedShellTopology\nTopologies.StackedCubedSphereTopology","category":"page"},{"location":"Mesh/#CLIMA.Topologies.AbstractTopology","page":"Mesh","title":"CLIMA.Topologies.AbstractTopology","text":"AbstractTopology{dim}\n\nRepresents the connectivity of individual elements, with local dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.BoxElementTopology","page":"Mesh","title":"CLIMA.Topologies.BoxElementTopology","text":"BoxElementTopology{dim, T} <: AbstractTopology{dim}\n\nThe local topology of a larger MPI-distributed topology, represented by dim-dimensional box elements.\n\nThis contains the necessary information for the connectivity elements of the elements on the local process, along with \"ghost\" elements from neighbouring processes.\n\nFields\n\nmpicomm\nMPI communicator for communicating with neighbouring processes.\n\nelems\nRange of element indices\n\nrealelems\nRange of real (aka nonghost) element indices\n\nghostelems\nRange of ghost element indices\n\nsendelems\nArray of send element indices sorted so that\n\nelemtocoord\nElement to vertex coordinates; elemtocoord[d,i,e] is the dth coordinate of corner i of element e\nnote: Note\ncurrently coordinates always are of size 3 for (x, y, z)\n\nelemtoelem\nElement to neighboring element; elemtoelem[f,e] is the number of the element neighboring element e across face f.  If there is no neighboring element then elemtoelem[f,e] == e.\n\nelemtoface\nElement to neighboring element face; elemtoface[f,e] is the face number of the element neighboring element e across face f.  If there is no neighboring element then elemtoface[f,e] == f.\"\n\nelemtoordr\nelement to neighboring element order; elemtoordr[f,e] is the ordering number of the element neighboring element e across face f.  If there is no neighboring element then elemtoordr[f,e] == 1.\n\nelemtobndy\nElement to bounday number; elemtobndy[f,e] is the boundary number of face f of element e.  If there is a neighboring element then elemtobndy[f,e] == 0.\n\nnabrtorank\nList of the MPI ranks for the neighboring processes\n\nnabrtorecv\nRange in ghost elements to receive for each neighbor\n\nnabrtosend\nRange in sendelems to send for each neighbor\n\nhasboundary\nboolean for whether or not this topology has a boundary\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.BrickTopology","page":"Mesh","title":"CLIMA.Topologies.BrickTopology","text":"BrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.StackedBrickTopology","page":"Mesh","title":"CLIMA.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topology, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.CubedShellTopology","page":"Mesh","title":"CLIMA.Topologies.CubedShellTopology","text":"CubedShellTopology{T} <: AbstractTopology{2}\n\nA cube-shell topology. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.StackedCubedSphereTopology","page":"Mesh","title":"CLIMA.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology{3, T} <: AbstractTopology{3}\n\nA cube-sphere topology. All elements on the same \"vertical\" dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#Constructors-1","page":"Mesh","title":"Constructors","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Topologies.BrickTopology(mpicomm, Nelems)\nTopologies.StackedBrickTopology(mpicomm, elemrange)\nTopologies.CubedShellTopology(mpicomm, Neside, T)\nTopologies.StackedCubedSphereTopology(mpicomm, Nhorz, Rrange)","category":"page"},{"location":"Mesh/#CLIMA.Topologies.BrickTopology-Tuple{Any,Any}","page":"Mesh","title":"CLIMA.Topologies.BrickTopology","text":"BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x_2-direction with\n\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\ntopology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                         periodicity=(false,true),\n                         boundary=[1 3; 2 4])\nMPI.Finalize()\n\nThis returns the mesh structure for\n\n         x_2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  3  |  4  |  5  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  2  |  6  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x_1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 3] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 5  5  6  6\n\n[:, :, 6] =\n 4  5  4  5\n 4  4  5  5\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"Mesh/#CLIMA.Topologies.StackedBrickTopology-Tuple{Any,Any}","page":"Mesh","title":"CLIMA.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)\n\nGenerate a stacked brick mesh topology with coordinates given by the tuple elemrange and the periodic dimensions given by the periodicity tuple.\n\nThe elements are stacked such that the elements associated with range elemrange[dim] are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.  Further, stacks are not split at MPI boundaries.\n\nBy default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in boundary.  This will mark the nonperiodic brick faces with the given boundary number.\n\nExamples\n\nWe can build a 3 by 2 element two-dimensional mesh that is periodic in the x_2-direction with\n\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\ntopology = StackedBrickTopology(MPI.COMM_SELF, (2:5,4:6);\n                                periodicity=(false,true),\n                                boundary=[1 3; 2 4])\nMPI.Finalize()\n\nThis returns the mesh structure stacked in the x_2-direction for\n\n         x_2\n\n          ^\n          |\n         6-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  2  |  4  |  6  |\n          |  |     |     |     |\n         5-  +-----+-----+-----+\n          |  |     |     |     |\n          |  |  1  |  3  |  5  |\n          |  |     |     |     |\n         4-  +-----+-----+-----+\n          |\n          +--|-----|-----|-----|--> x_1\n             2     3     4     5\n\nFor example, the (dimension by number of corners by number of elements) array elemtocoord gives the coordinates of the corners of each element.\n\njulia> topology.elemtocoord\n2×4×6 Array{Int64,3}:\n[:, :, 1] =\n 2  3  2  3\n 4  4  5  5\n\n[:, :, 2] =\n 2  3  2  3\n 5  5  6  6\n\n[:, :, 3] =\n 3  4  3  4\n 4  4  5  5\n\n[:, :, 4] =\n 3  4  3  4\n 5  5  6  6\n\n[:, :, 5] =\n 4  5  4  5\n 4  4  5  5\n\n[:, :, 6] =\n 4  5  4  5\n 5  5  6  6\n\nNote that the corners are listed in Cartesian order.\n\nThe (number of faces by number of elements) array elemtobndy gives the boundary number for each face of each element.  A zero will be given for connected faces.\n\njulia> topology.elemtobndy\n4×6 Array{Int64,2}:\n 1  0  1  0  0  0\n 0  0  0  0  2  2\n 0  0  0  0  0  0\n 0  0  0  0  0  0\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"Mesh/#CLIMA.Topologies.CubedShellTopology-Tuple{Any,Any,Any}","page":"Mesh","title":"CLIMA.Topologies.CubedShellTopology","text":"CubedShellTopology(mpicomm, Nelem, T) <: AbstractTopology{dim}\n\nGenerate a cubed shell mesh with the number of elements along each dimension of the cubes being Nelem. This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type T.\n\nThe elements of the shell are partitioned equally across the MPI ranks based on a space-filling curve.\n\nNote that this topology is logically 2-D but embedded in a 3-D space\n\nExamples\n\nWe can build a cubed shell mesh with 10 elements on each cube, total elements is 10 * 10 * 6 = 600, with\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\ntopology = CubedShellTopology(MPI.COMM_SELF, 10, Float64)\n\n# Typically the warping would be done after the grid is created, but the cell\n# corners could be warped with...\n\n# Shell radius = 1\nx, y, z = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x)\n   x[n], y[n], z[n] = Topologies.cubedshellwarp(x[n], y[n], z[n])\nend\n\n# Shell radius = 10\nx, y, z = ntuple(j->topology.elemtocoord[j, :, :], 3)\nfor n = 1:length(x)\n  x[n], y[n], z[n] = Topologies.cubedshellwarp(x[n], y[n], z[n], 10)\nend\n\nMPI.Finalize()\n\n\n\n\n\n","category":"method"},{"location":"Mesh/#CLIMA.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}","page":"Mesh","title":"CLIMA.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology(mpicomm, Nhorz, Rrange;                               bc=(1,1)) <: AbstractTopology{3}\n\nGenerate a stacked cubed sphere topology with Nhorz by Nhorz cells for each horizontal face and Rrange is the radius edges of the stacked elements.  This topology actual creates a cube mesh, and the warping should be done after the grid is created using the cubedshellwarp function. The coordinates of the points will be of type eltype(Rrange). The inner boundary condition type is bc[1] and the outer boundary condition type is bc[2].\n\nThe elements are stacked such that the vertical elements are contiguous in the element ordering.\n\nThe elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve. Further, stacks are not split at MPI boundaries.\n\nExamples\n\nWe can build a cubed sphere mesh with 10 x 10 x 5 elements on each cube, total elements is 10 * 10 * 5 * 6 = 3000, with\n\nusing CLIMA.Topologies\nusing MPI\nMPI.Init()\nNhorz = 10\nNstack = 5\nRrange = Float64.(accumulate(+,1:Nstack+1))\ntopology = StackedCubedSphereTopology(MPI.COMM_SELF, Nhorz, Rrange)\n\nx, y, z = ntuple(j->reshape(topology.elemtocoord[j, :, :],\n                            2, 2, 2, length(topology.elems)), 3)\nfor n = 1:length(x)\n   x[n], y[n], z[n] = Topologies.cubedshellwarp(x[n], y[n], z[n])\nend\n\nMPI.Finalize()\n\nNote that the faces are listed in Cartesian order.\n\n\n\n\n\n","category":"method"},{"location":"Mesh/#Functions-1","page":"Mesh","title":"Functions","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Topologies.cubedshellmesh\nTopologies.cubedshellwarp\nTopologies.hasboundary","category":"page"},{"location":"Mesh/#CLIMA.Topologies.cubedshellmesh","page":"Mesh","title":"CLIMA.Topologies.cubedshellmesh","text":"cubedshellmesh(T, Ne; part=1, numparts=1)\n\nGenerate a cubed mesh with each of the \"cubes\" has an Ne X Ne grid of elements.\n\nThe mesh can optionally be partitioned into numparts and this returns partition part.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.\n\nThis mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.\n\nThe mesh structures for the cubes is as follows:\n\nx_2\n   ^\n   |\n4Ne-           +-------+\n   |           |       |\n   |           |   6   |\n   |           |       |\n3Ne-           +-------+\n   |           |       |\n   |           |   5   |\n   |           |       |\n2Ne-           +-------+\n   |           |       |\n   |           |   4   |\n   |           |       |\n Ne-   +-------+-------+-------+\n   |   |       |       |       |\n   |   |   1   |   2   |   3   |\n   |   |       |       |       |\n  0-   +-------+-------+-------+\n   |\n   +---|-------|-------|------|-> x_1\n       0      Ne      2Ne    3Ne\n\n\n\n\n\n","category":"function"},{"location":"Mesh/#CLIMA.Topologies.cubedshellwarp","page":"Mesh","title":"CLIMA.Topologies.cubedshellwarp","text":"cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))\n\nGiven points (a, b, c) on the surface of a cube, warp the points out to a spherical shell of radius R based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) https://dx.doi.org/10.1006/jcph.1996.0047\n\n@article{RonchiIaconoPaolucci1996,\n  title={The ``cubed sphere'': a new method for the solution of partial\n         differential equations in spherical geometry},\n  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},\n  journal={Journal of Computational Physics},\n  volume={124},\n  number={1},\n  pages={93--114},\n  year={1996},\n  doi={10.1006/jcph.1996.0047}\n}\n\n\n\n\n\n","category":"function"},{"location":"Mesh/#CLIMA.Topologies.hasboundary","page":"Mesh","title":"CLIMA.Topologies.hasboundary","text":"hasboundary(topology::AbstractTopology)\n\nquery function to check whether a topology has a boundary (i.e., not fully periodic)\n\n\n\n\n\n","category":"function"},{"location":"Mesh/#Grids-1","page":"Mesh","title":"Grids","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Grids specify the approximation within each element, and any necessary warping.","category":"page"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Grids.DiscontinuousSpectralElementGrid","category":"page"},{"location":"Mesh/#CLIMA.Grids.DiscontinuousSpectralElementGrid","page":"Mesh","title":"CLIMA.Grids.DiscontinuousSpectralElementGrid","text":"DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,\n                                 polynomialorder,\n                                 meshwarp = (x...)->identity(x))\n\nGenerate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a topology, where the order of the elements is given by polynomialorder. DeviceArray gives the array type used to store the data (CuArray or Array), and the coordinate points will be of FloatType.\n\nThe optional meshwarp function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.\n\n\n\n\n\n","category":"type"},{"location":"AtmosDycore/#AtmosDycore-1","page":"AtmosDycore","title":"AtmosDycore","text":"","category":"section"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"CurrentModule = CLIMA.AtmosDycore","category":"page"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"getrhsfunction","category":"page"},{"location":"AtmosDycore/#CLIMA.AtmosDycore.getrhsfunction","page":"AtmosDycore","title":"CLIMA.AtmosDycore.getrhsfunction","text":"getrhsfunction(disc::AbstractAtmosDiscretization)\n\nThe spatial discretizations are of the form Q = f(Q), and this function returns the handle to right-hand side function f of the disc\n\n\n\n\n\n","category":"function"},{"location":"AtmosDycore/#VanillaAtmosDiscretizations-1","page":"AtmosDycore","title":"VanillaAtmosDiscretizations","text":"","category":"section"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"A discretization adds additional information for the atmosphere problem.","category":"page"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"VanillaAtmosDiscretizations.VanillaAtmosDiscretization\nVanillaAtmosDiscretizations.estimatedt","category":"page"},{"location":"AtmosDycore/#CLIMA.AtmosDycore.VanillaAtmosDiscretizations.VanillaAtmosDiscretization","page":"AtmosDycore","title":"CLIMA.AtmosDycore.VanillaAtmosDiscretizations.VanillaAtmosDiscretization","text":"VanillaAtmosDiscretization{nmoist, ntrace}(grid; gravity = true,\nviscosity = 0)\n\nGiven a 'grid <: AbstractGrid' this construct all the data necessary to run a vanilla discontinuous Galerkin discretization of the the compressible Euler equations with nmoist moisture variables and ntrace tracer variables. If the boolean keyword argument gravity is true then gravity is used otherwise it is not. Isotropic viscosity can be used if viscosity is set to a positive constant.\n\n\n\n\n\n","category":"type"},{"location":"AtmosDycore/#CLIMA.AtmosDycore.VanillaAtmosDiscretizations.estimatedt","page":"AtmosDycore","title":"CLIMA.AtmosDycore.VanillaAtmosDiscretizations.estimatedt","text":"estimatedt(disc::VanillaAtmosDiscretization, Q::MPIStateArray)\n\nGiven a discretization disc and a state Q compute an estimate for the time step\n\ntodo: Todo\nThis estimate is currently very conservative, needs to be revisited\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Arrays-1","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"Arrays/#","page":"Arrays","title":"Arrays","text":"CurrentModule = CLIMA","category":"page"},{"location":"Arrays/#MPIStateArrays-1","page":"Arrays","title":"MPIStateArrays","text":"","category":"section"},{"location":"Arrays/#","page":"Arrays","title":"Arrays","text":"Storage for the state of a discretization.","category":"page"},{"location":"Arrays/#","page":"Arrays","title":"Arrays","text":"MPIStateArrays.MPIStateArray\nMPIStateArrays.post_Irecvs!\nMPIStateArrays.start_ghost_exchange!\nMPIStateArrays.finish_ghost_exchange!","category":"page"},{"location":"Arrays/#CLIMA.MPIStateArrays.MPIStateArray","page":"Arrays","title":"CLIMA.MPIStateArrays.MPIStateArray","text":"MPIStateArray{S <: Tuple, T, DeviceArray, N,\n              DATN<:AbstractArray{T,N}, Nm1, DAI1} <: AbstractArray{T, N}\n\nN-dimensional MPI-aware array with elements of type T. The dimension N is length(S) + 1. S is a tuple of the first N-1 array dimensions.\n\ntodo: Todo\nIt should be reevaluated whether all this stuff in the type domain is really necessary (some of it was optimistically added for functionality that never panned out)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#CLIMA.MPIStateArrays.post_Irecvs!","page":"Arrays","title":"CLIMA.MPIStateArrays.post_Irecvs!","text":"post_Irecvs!(Q::MPIStateArray)\n\nposts the MPI.Irecv! for Q\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#CLIMA.MPIStateArrays.start_ghost_exchange!","page":"Arrays","title":"CLIMA.MPIStateArrays.start_ghost_exchange!","text":"start_ghost_exchange!(Q::MPIStateArray; dorecvs=true)\n\nStart the MPI exchange of the data stored in Q. If dorecvs is true then post_Irecvs!(Q) is called, otherwise the caller is responsible for this.\n\nThis function will fill the send buffer (on the device), copies the data from the device to the host, and then issues the send. Previous sends are waited on to ensure that they are complete.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#CLIMA.MPIStateArrays.finish_ghost_exchange!","page":"Arrays","title":"CLIMA.MPIStateArrays.finish_ghost_exchange!","text":"finish_ghost_exchange!(Q::MPIStateArray)\n\nComplete the exchange of data and fill the data array on the device. Note this completes both the send and the receive communication. For more fine level control see finishghostexchange_recv! and finishghostexchange_send!\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#ODESolvers-1","page":"DGmethods","title":"ODESolvers","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"CurrentModule = CLIMA","category":"page"},{"location":"DGmethods/#SpaceMethods-1","page":"DGmethods","title":"SpaceMethods","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"Set of abstract types for spatial discretizations","category":"page"},{"location":"DGmethods/#Types-1","page":"DGmethods","title":"Types","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"SpaceMethods.AbstractSpaceMethod\nSpaceMethods.AbstractDGMethod","category":"page"},{"location":"DGmethods/#CLIMA.SpaceMethods.AbstractSpaceMethod","page":"DGmethods","title":"CLIMA.SpaceMethods.AbstractSpaceMethod","text":"AbstractSpaceMethod\n\nSupertype for spatial discretizations\n\n\n\n\n\n","category":"type"},{"location":"DGmethods/#CLIMA.SpaceMethods.AbstractDGMethod","page":"DGmethods","title":"CLIMA.SpaceMethods.AbstractDGMethod","text":"AbstractDGMethod <: AbstractSpaceMethod\n\nSupertype for discontinuous Galerkin spatial discretizations\n\n\n\n\n\n","category":"type"},{"location":"DGmethods/#Functions-1","page":"DGmethods","title":"Functions","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"SpaceMethods.odefun!","category":"page"},{"location":"DGmethods/#CLIMA.SpaceMethods.odefun!","page":"DGmethods","title":"CLIMA.SpaceMethods.odefun!","text":"odefun!(disc::DGBalanceLaw, dQ::MPIStateArray, Q::MPIStateArray, t)\n\nEvaluates the right-hand side of the discontinuous Galerkin semi-discretization defined by disc at time t with state Q. The result is added into dQ. Namely, the semi-discretization is of the form\n\nQ = F(Q t)\n\nand after the call dQ += F(Q, t)\n\n\n\n\n\nodefun!(disc::AbstractSpaceMethod, dQ, Q, t)\n\nEvaluates the right-hand side of the spatial discretization defined by disc at time t with state Q. The result is added into dQ. Namely, the semi-discretization is of the form Q = F(Q t) and after the call dQ += F(Q, t)\n\nnote: Note\nThere is no generic implementation of this function. This must be implemented for each subtype of AbstractSpaceMethod\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#DGBalanceLawDiscretizations-1","page":"DGmethods","title":"DGBalanceLawDiscretizations","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"DGBalanceLawDiscretizations","category":"page"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations","text":"DG Balance Law Discretizations module. Attempts to provide a reasonable implementation of a discontinuous Galerkin method (in weak form) on tensor product quadrilateral (2D) and hexahedral (3D) elements for balance laws of the form\n\nq_t + Σ_i=1d F_ii = s\n\nwhere q is the state vector, F is the flux function, and s is the source function. F includes both the \"inviscid\" and \"viscous\" fluxes. Note that this is a space only discretization, time must be advanced using some ordinary differential equations methods; see ODESolvers.\n\nMuch of the notation used in this module follows Hesthaven and Warburton (2008).\n\nnote: Note\nWe plan to switch to a skew-symmetric formulation (at which time this note will be removed)\n\nreferences: References\n@BOOK{HesthavenWarburton2008,\n  title = {Nodal Discontinuous {G}alerkin Methods: {A}lgorithms, Analysis,\n           and Applications},\n  publisher = {Springer-Verlag New York},\n  year = {2008},\n  author = {Hesthaven, Jan S. and Warburton, Tim},\n  volume = {54},\n  series = {Texts in Applied Mathematics},\n  doi = {10.1007/978-0-387-72067-8}\n}\n\n\n\n\n\n","category":"module"},{"location":"DGmethods/#Types-2","page":"DGmethods","title":"Types","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"DGBalanceLawDiscretizations.DGBalanceLaw","category":"page"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw","text":"DGBalanceLaw <: AbstractDGMethod\n\nThis contains the necessary information for a discontinuous Galerkin method for balance laws.\n\nSee also: Outer constructor DGBalanceLaw\n\nFields\n\ngrid\ncomputational grid / mesh\nnstate\nnumber of state\ngradstates\ntuple of states to take the gradient of\ninviscid_flux!\nphysical inviscid flux function\ninviscid_numerical_flux!\ninviscid numerical flux function\ninviscid_numerical_boundary_flux!\ninviscid numerical boundary flux function\nQgrad\nstorage for the grad\nauxstate\nauxiliary state array\nsource!\nsource function\n\n\n\n\n\n","category":"type"},{"location":"DGmethods/#Constructor-1","page":"DGmethods","title":"Constructor","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"DGBalanceLawDiscretizations.DGBalanceLaw(;)","category":"page"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw","text":" DGBalanceLaw(; grid::DiscontinuousSpectralElementGrid, length_state_vector,\n              inviscid_flux!, inviscid_numerical_flux!,\n              inviscid_numerical_boundary_flux! = nothing,\n              auxiliary_state_length=0,\n              auxiliary_state_initialization! = nothing,\n              source! = nothing)\n\nConstructs a DGBalanceLaw spatial discretization type for the physics defined by inviscid_flux! and source!. The computational domain is defined by grid. The number of state variables is defined by length_state_vector. The user may also specify an auxiliary state which will be unpacked by the compute kernel passed on to the user-defined flux and numerical flux functions. The source function source! is optional.\n\nThe inviscid flux function is called with data from a degree of freedom (DOF) as\n\ninviscid_flux!(F, Q, aux, t)\n\nwhere\n\nF is an MArray of size (dim, length_state_vector) to be filled (note that this is uninitialized so the user must set to zero if is this desired)\nQ is the state to evaluate (MArray)\naux is the user-defined auxiliary state (MArray)\nt is the current simulation time\n\nWarning: Modifications to Q or aux may cause side effects and should be avoided.\n\nThe inviscid numerical flux function is called with data from two DOFs as\n\ninviscid_numerical_flux!(F, nM, QM, auxM, QP, auxP, t)\n\nwhere\n\nF is an MArray of size (dim, length_state_vector) to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero if is this desired)\nnM is the unit outward normal to the face with respect to the minus side (MVector of length 3)\nQM and QP are the minus and plus side states (MArray)\nauxM and auxP are the auxiliary states (MArray)\nt is the current simulation time\n\nWarning: Modifications to nM, QM, auxM, QP, or auxP may cause side effects and should be avoided.\n\nIf grid.topology has a boundary then the function inviscid_numerical_boundary_flux! must be specified. This function is called with the data from the neighbouring DOF as\n\ninviscid_numerical_boundary_flux!(F, nM, QM, auxM, QP, auxP, bctype, t)\n\nwhere\n\nF is an MArray of size (dim, length_state_vector) to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero is this desired)\nnM is the unit outward normal to the face with respect to the minus side (MVector of length 3)\nQM and QP are the minus and plus side states (MArray)\nauxM and auxP are the auxiliary states (MArray)\nbctype is the boundary condition flag for the connected face and element of  grid.elemtobndy\nt is the current simulation time\n\nNote: QP and auxP are filled with values based on degrees of freedom referenced in grid.vmapP; QP and auxP may be modified by the calling function.\n\nWarning: Modifications to nM, QM, or auxM may cause side effects and should be avoided.\n\nIf present the source function is called with data from a DOF as\n\nsource!(S, Q, aux, t)\n\nwhere S is an MVector of length length_state_vector to be filled; other arguments are the same as inviscid_flux! and the same warning concerning Q and aux applies.\n\nWhen auxiliary_state_initialization! !== nothing then this is called on the auxiliary state (assuming auxiliary_state_length > 0) as\n\nauxiliary_state_initialization!(aux, x, y, z)\n\nwhere aux is an MArray to fill with the auxiliary state for a DOF located at Cartesian coordinate locations (x, y, z); see also grad_auxiliary_state! allows the user to take the gradient of a field stored in the auxiliary state.\n\nnote: Note\nIf (x, y, z), or data derived from this such as spherical coordinates, is needed in the flux or source the user is responsible to storing this in the auxiliary state\n\ntodo: Todo\nsupport viscous fluxes (gradstates is in the argument list as part of this future interface)\nRevisit how to handle plus side state in inviscid_numerical_boundary_flux! after gradient state is handled (how to or not propagate changes without adverse side effects).\n\n\n\n\n\n","category":"method"},{"location":"DGmethods/#Functions-2","page":"DGmethods","title":"Functions","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"DGBalanceLawDiscretizations.writevtk\nDGBalanceLawDiscretizations.writevtk_helper\nDGBalanceLawDiscretizations.grad_auxiliary_state!","category":"page"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.writevtk","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.writevtk","text":"writevtk(prefix, Q::MPIStateArray, disc::DGBalanceLaw [, fieldnames])\n\nWrite a vtk file for all the fields in the state array Q using geometry and connectivity information from disc.grid. The filename will start with prefix which may also contain a directory path. The names used for each of the fields in the vtk file can be specified through the collection of strings fieldnames; if not specified the fields names will be \"Q1\" through \"Qk\" where k is the number of states in Q, i.e., k = size(Q,2).\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.writevtk_helper","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.writevtk_helper","text":"writevtk_helper(prefix, vgeo::Array, Q::Array, grid, fieldnames)\n\nInternal helper function for writevtk\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!","text":"grad_auxiliary_state!(disc, i, (ix, iy, iz))\n\nComputes the gradient of a the field i of the constant auxiliary state of disc and stores the x, y, z compoment in fields ix, iy, iz of constant auxiliary state.\n\nnote: Note\nThis only computes the element gradient not a DG gradient. If your constant auxiliary state is discontinuous this may or may not be what you want!\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#Pirated-Type-Functions-1","page":"DGmethods","title":"Pirated Type Functions","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"CLIMA.MPIStateArrays.MPIStateArray(::DGBalanceLawDiscretizations.DGBalanceLaw)\nCLIMA.MPIStateArrays.MPIStateArray(::DGBalanceLawDiscretizations.DGBalanceLaw, ::Function)\nCLIMA.SpaceMethods.odefun!(::DGBalanceLawDiscretizations.DGBalanceLaw, dQ, Q, t)","category":"page"},{"location":"DGmethods/#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}","page":"DGmethods","title":"CLIMA.MPIStateArrays.MPIStateArray","text":"MPIStateArray(disc::DGBalanceLaw; commtag=888)\n\nGiven a discretization disc constructs an MPIStateArrays for holding a solution state. The optional commtag allows the user to set the tag to use for communication with this MPIStateArray.\n\n\n\n\n\n","category":"method"},{"location":"DGmethods/#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}","page":"DGmethods","title":"CLIMA.MPIStateArrays.MPIStateArray","text":"MPIStateArray(disc::DGBalanceLaw, initialization!::Function; commtag=888)\n\nGiven a discretization disc constructs an MPIStateArrays for holding a solution state. The optional commtag allows the user to set the tag to use for communication with this MPIStateArray.\n\nAfter allocation the MPIStateArray is initialized using the function initialization! which will be called as:\n\ninitialization!(Q, x, y, z, [aux])\n\nwhere Q is an MArray with the solution state at a single degree of freedom (DOF) to initialize and (x,y,z) is the coordinate point for the allocation. If disc contains an auxiliary data the values of this at the DOF are passed through as an MArray through the aux argument\n\nnote: Note\nQ is undef at start the function (i.e., not initialized to zero)\n\nnote: Note\nModifications of the aux array will be discarded.\n\ntodo: Todo\nGPUify this function to remove host and device data transfers\n\n\n\n\n\n","category":"method"},{"location":"DGmethods/#CLIMA.SpaceMethods.odefun!-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Any,Any,Any}","page":"DGmethods","title":"CLIMA.SpaceMethods.odefun!","text":"odefun!(disc::AbstractSpaceMethod, dQ, Q, t)\n\nEvaluates the right-hand side of the spatial discretization defined by disc at time t with state Q. The result is added into dQ. Namely, the semi-discretization is of the form Q = F(Q t) and after the call dQ += F(Q, t)\n\nnote: Note\nThere is no generic implementation of this function. This must be implemented for each subtype of AbstractSpaceMethod\n\n\n\n\n\n","category":"method"},{"location":"DGmethods/#Kernels-1","page":"DGmethods","title":"Kernels","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"DGBalanceLawDiscretizations.volumerhs!\nDGBalanceLawDiscretizations.facerhs!\nDGBalanceLawDiscretizations.initauxstate!\nDGBalanceLawDiscretizations.elem_grad_field!","category":"page"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.volumerhs!","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.volumerhs!","text":"volumerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{ngradstate},\n           ::Val{nauxstate}, flux!, source!, rhs::Array, Q, Qgrad, auxstate,\n           vgeo, t, D, elems) where {dim, N, nstate, ngradstate,\n\nComputational kernel: Evaluate the volume integrals on right-hand side of a DGBalanceLaw semi-discretization.\n\nSee odefun! for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.facerhs!","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.facerhs!","text":"facerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{ngradstate},\n         ::Val{nauxstate}, inviscid_numerical_flux!,\n         inviscid_numerical_boundary_flux!, rhs::Array, Q, Qgrad, auxstate,\n         vgeo, sgeo, t, vmapM, vmapP, elemtobndy,\n         elems) where {dim, N, nstate, ngradstate, nauxstate}\n\nComputational kernel: Evaluate the surface integrals on right-hand side of a DGBalanceLaw semi-discretization.\n\nSee odefun! for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.initauxstate!","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.initauxstate!","text":"initauxstate!(::Val{dim}, ::Val{N}, ::Val{nauxstate}, auxstatefun!,\n              auxstate, vgeo, elems) where {dim, N, nauxstate}\n\nComputational kernel: Initialize the auxiliary state\n\nSee DGBalanceLaw for usage.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.elem_grad_field!","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.elem_grad_field!","text":"elem_grad_field!(::Val{dim}, ::Val{N}, ::Val{nstate}, Q, vgeo, D, elems, s,\n                 sx, sy, sz) where {dim, N, nstate}\n\nComputational kernel: Compute the element gradient of state s of Q and store it in sx, sy, and sz of Q.\n\nwarning: Warning\nThis does not compute a DG gradient, but only over the element. If Q_s is discontinuous you may want to consider another approach.\n\n\n\n\n\n","category":"function"},{"location":"DGmethods/#DGBalanceLawDiscretizations.NumericalFluxes-1","page":"DGmethods","title":"DGBalanceLawDiscretizations.NumericalFluxes","text":"","category":"section"},{"location":"DGmethods/#","page":"DGmethods","title":"DGmethods","text":"DGBalanceLawDiscretizations.NumericalFluxes.rusanov!","category":"page"},{"location":"DGmethods/#CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!","page":"DGmethods","title":"CLIMA.DGBalanceLawDiscretizations.NumericalFluxes.rusanov!","text":"rusanov!(F::MArray, nM, QM, auxM, QP, auxP, t, flux!, wavespeed,\n         [preflux = (_...) -> (), correctQ!])\n\nCalculate the Rusanov (aka local Lax-Friedrichs) numerical flux given the plus and minus side states QP and QM using the physical flux function flux! and wavespeed calculation.\n\nThe flux! has almost the same calling convention as inviscid_flux! from DGBalanceLaw except that preflux(Q, aux, t) is splatted at the end of the call.\n\nThe function wavespeed should return the maximum wavespeed for a state and is called as wavespeed(nM, QM, auxM, t, preflux(QM, auxM, t)...) and wavespeed(nM, QP, auxP, t, preflux(QP, auxP, t)...) where nM is the outward unit normal for the minus side.\n\nWhen present correctQ!(QM, auxM) and correctQ!(QP, auxP) will be after wavespeed and flux! are called to the user can modify QM and QP before QM - QP is needed; this is useful for correcting Q to include discontinuous reference states.\n\ntodo: Todo\nWe may want to switch to a computed_jump! instead of correctQ! since this would allow the user to better handle round-off error with large background states.\n\nnote: Note\nThe undocumented arguments PM and PP for the function should not be used by external callers and are used only internally by the function rusanov_boundary_flux!\n\n\n\n\n\n","category":"function"},{"location":"CodingConventions/#Coding-Conventions-1","page":"Coding Conventions","title":"Coding Conventions","text":"","category":"section"},{"location":"CodingConventions/#","page":"Coding Conventions","title":"Coding Conventions","text":"A list of recommended coding conventions.","category":"page"},{"location":"CodingConventions/#","page":"Coding Conventions","title":"Coding Conventions","text":"There are good recommendations in the Julia style-guide:\nhttps://docs.julialang.org/en/v1/manual/style-guide/index.html\nhttps://docs.julialang.org/en/v0.6/manual/packages/#Guidelines-for-naming-a-package-1\nPlease only use Unicode characters that are within our list of acceptable Unicode characters (in AcceptableUnicode.md).\nModules, and class names (structs), should follow TitleCase convention. Note that class names cannot coincide with module names.\nFunction names should be lowercase, with words separated by underscores as necessary to improve readability.\nVariable names follow the same convention as function names. Follow CMIP conventions (http://clipc-services.ceda.ac.uk/dreq/) where possible and practicable.\nMake names consistent, distinctive, and meaningful.\nDocument design and purpose, rather than mechanics and implementation (document interfaces and embed documentation in code).\nAvoid variable names that coincide with module and class names, as well as function/variable names that are natively supported.\nNever use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names.\nTwo white spaces are used for indent. This is not part of the standard convention, but recent development efforts have been using this indentation style (e.g., Google's Tensorflow), and this style is being used here also.\nKISS (keep it simple stupid).\nTry to limit all lines to a maximum of 79 characters.\nSingle access point - if a variable/constant is defined more than once, then move it into a module and import (or \"using\") to that module to access the variable in order to enforce a single access point (to avoid consistency issues). Any time a chunk of code is used more than once, or when several similar versions exist across the codebase, consider generalizing this functionality and using a new function to avoid replicating code\n\"import\"/\"using\" should be grouped in the following order:\nStandard library imports.\nRelated third party imports.\nLocal application/library specific imports.\nUse a blank line between each group of imports.","category":"page"},{"location":"CodingConventions/#Why-do-we-limit-our-Unicode-use?-1","page":"Coding Conventions","title":"Why do we limit our Unicode use?","text":"","category":"section"},{"location":"CodingConventions/#","page":"Coding Conventions","title":"Coding Conventions","text":"Some characters are visibly indistinguishable. Capital \"a\" and capital alpha are visibly indistinguishable, but are recognized as separate characters (e.g., search distinguishable).\nSome characters are difficult to read. Sometimes, the overline/overdot/hats overlap with characters making them difficult to see.\nPortability issues. Unicode does not render in Jupyter notebook natively (on OSX).\nIf it does improve readability enough, and are not worried about portability, we may introduce a list of permissible characters that are commonly used.","category":"page"},{"location":"AcceptableUnicode/#Acceptable-Unicode-characters-1","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"Using Unicode seems to be irresistible. However, we must ensure avoiding problematic Unicode usage.","category":"page"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"Below is a list of acceptable Unicode characters. All characters not listed below are forbidden. We forbid the use of accents (dot, hat, vec, etc.), because this can lead to visually ambiguous characters.","category":"page"},{"location":"AcceptableUnicode/#Acceptable-lower-case-Greek-letters-1","page":"Acceptable Unicode characters","title":"Acceptable lower-case Greek letters","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"α # (alpha)\nβ # (beta)\nδ # (delta)\nϵ # (epsilon)\nε # (varepsilon)\nγ # (gamma)\nκ # (kappa)\nλ # (lambda)\nμ # (mu)\nν # (nu)\nη # (eta)\nω # (omega)\nπ # (pi)\nρ # (rho)\nσ # (sigma)\nθ # (theta)\nχ # (chi)\nξ # (xi)\nζ # (zeta)\nϕ # (psi)\nφ # (varphi)","category":"page"},{"location":"AcceptableUnicode/#Acceptable-upper-case-Greek-letters-1","page":"Acceptable Unicode characters","title":"Acceptable upper-case Greek letters","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"Δ # (Delta)\n∑ # (Sigma)\nΓ # (Gamma)\nΩ # (Omega)\nΨ # (Psi)\n<!-- Φ # (Phi) removed in favor of lowercase psi -->","category":"page"},{"location":"AcceptableUnicode/#Acceptable-mathematical-symbols-1","page":"Acceptable Unicode characters","title":"Acceptable mathematical symbols","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters","title":"Acceptable Unicode characters","text":"∫ # (int)\n∬ # (iint)\n∭ # (iiint)\n∞ # (infinity)\n≈ # (approx)\n∂ # (partial)\n∇ # (nabla/del), note that nabla and del are indistinguishable\n∀ # (forall)\n≥ # (greater than equal to)\n≤ # (less than equal to)\n<!-- ∈ # (in) removed in favor of epsilon -->","category":"page"},{"location":"VariableList/#CliMA-Variable-List-1","page":"CliMA Variable List","title":"CliMA Variable List","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"This document is currently for collaborators within the project with access to the Overleaf CliMA-Atmos docs. The purpose of this page is to unify the naming conventions used in the Overleaf document in a manner useful for coding. This document suggests 'reserved' variable names in <property>_<species> format with the default working fluid (no-subscript) being moist air. Contributors to the CliMA repository are welcome to suggest changes when necessary.","category":"page"},{"location":"VariableList/#Names-reserved-for-'use-and-throw'-/-debug-variables-1","page":"CliMA Variable List","title":"Names reserved for 'use and throw' / debug variables","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"dummy\nscratch","category":"page"},{"location":"VariableList/#.1-Working-Fluid-and-Equation-of-State-1","page":"CliMA Variable List","title":"2.1  Working Fluid and Equation of State","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"q_dry = dry air mass fraction\nq_vap = specific humidity, vapour\nq_liq = specific humidity, liquid\nq_ice = specific humidity, ice\nq_con = specific humidity, condensate\nq_tot = specific humidity, total\n\n\nP_<species>     = pressure, species (no subscript == default working fluid moist air)\nρ_<species>     = density, species (no subscript == default working fluid moist air)\nR_m             = gas constant, moist\nR_d             = gas constant, dry\nR_v             = gas constant, water vapour\nT               = temperature, moist air\nT_<species>     = temperature, species","category":"page"},{"location":"VariableList/#.2-Mass-Balance-1","page":"CliMA Variable List","title":"2.2 Mass Balance","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"dt              = time increment\nu               = x-velocity\nv               = y-velocity\nw               = z-velocity\nU               = x-momentum\nV               = y-momentum\nW               = z=momentum","category":"page"},{"location":"VariableList/#.3-Moisture-balances-1","page":"CliMA Variable List","title":"2.3 Moisture balances","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"source_qt           = local source/sink of water mass [S_qt]\ndiffusiveflux_vap   = diffusive flux, water vapour\ndiffusiveflux_liq   = diffusive flux, cloud liquid\ndiffusiveflux_ice   = diffusive flux, cloud ice\ndiffusiveflux_tot   = diffusive flux, total","category":"page"},{"location":"VariableList/#.4-Momentum-balances-1","page":"CliMA Variable List","title":"2.4 Momentum balances","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"U               = x-momentum\nV               = y-momentum\nW               = z-momentum (2D/3D: this is the vertical coordinate)\nΩ_x             = x-angular momentum\nΩ_y             = y-angular momentum\nΩ_z             = z-angular momentum\nτ_xx            = stress tensor ((1,1) component)\nτ_<ij>          = replace ij with combination of x/y/z to recover appropriate value\nλ_stokes        = Stokes parameter","category":"page"},{"location":"VariableList/#.5-Energy-balance-1","page":"CliMA Variable List","title":"2.5 Energy balance","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"<Lower case e_<type> suggests specific (per unit mass) quantities>\ne_kin_<spe>      = specific energy per unit volume, kinetic\ne_pot_<spe>      = specific energy per unit volume, potential\ne_int_<spe>      = specific energy per unit volume, internal\ne_tot_<spe>      = specific energy per unit volume, total\n\nE_kin_<spe>      = energy, kinetic\nE_pot_<spe>      = energy, potential\nE_int_<spe>      = energy, internal\nE_tot_<spe>      = energy, total\n\ncv_m             = isochoric specific heat, moist air\ncv_d             = isochoric specific heat, dry air\ncv_l             = isochoric specific heat, liquid water\ncv_v             = isochoric specific heat, water vapour\ncv_i             = isochoric specific heat, ice\n\ncp_m             = isobaric specific heat, moist air\ncp_d             = isobaric specific heat, dry air\ncp_l             = isobaric specific heat, liquid water\ncp_v             = isobaric specific heat, water vapour\ncp_i             = isobaric specific heat, ice","category":"page"},{"location":"VariableList/#TODO-1","page":"CliMA Variable List","title":"TODO","text":"","category":"section"},{"location":"VariableList/#","page":"CliMA Variable List","title":"CliMA Variable List","text":"Update with list of additional parameters / source terms as necessary","category":"page"}]
}

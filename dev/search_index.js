var documenterSearchIndex = {"docs":
[{"location":"#CLIMA-1","page":"Home","title":"CLIMA","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Climate Machine","category":"page"},{"location":"Utilities/RootSolvers/#RootSolvers-1","page":"RootSolvers","title":"RootSolvers","text":"","category":"section"},{"location":"Utilities/RootSolvers/#","page":"RootSolvers","title":"RootSolvers","text":"CurrentModule = CLIMA.RootSolvers","category":"page"},{"location":"Utilities/RootSolvers/#","page":"RootSolvers","title":"RootSolvers","text":"RootSolvers\nfind_zero","category":"page"},{"location":"Utilities/RootSolvers/#CLIMA.RootSolvers","page":"RootSolvers","title":"CLIMA.RootSolvers","text":"RootSolvers\n\nModule containing functions for solving roots of non-linear equations. The returned result is a tuple of the root and a Bool indicating convergence.\n\nfind_zero(f::F,\n           x_0::T,\n           x_1::T,\n           args::Tuple,\n           iter_params::IterParams{R, Int},\n           method::RootSolvingMethod\n           )::Tuple{T, Bool} where {F, R, T <: Union{R, AbstractArray{R}}}\n\n\n\nInterface\n\nfind_zero compute x^* such that f(x^*) = 0\n\nArguments\n\nf equation roots function, where f is callable via f(x, args...)\nx_0, x_1 initial guesses\nIterParams struct containing absolute tolerance on f(x^*) and maximum iterations\nRootSolvingMethod Algorithm to solve roots of the equation:\nSecantMethod Secant method\nRegulaFalsiMethod Regula Falsi Method\n\nSingle example\n\njulia> using RootSolvers\nx_0 = 0.0\nx_1 = 1.0\nf(x, y) = x^2 - y\nx_star2 = 10000.0\nargs = Tuple(x_star2)\nx_star = sqrt(x_star2)\ntol_abs = 1.0e-3\niter_max = 100\n\nx_root, converged = find_zero(f,\n                              x_0,\n                              x_1,\n                              args,\n                              IterParams(tol_abs, iter_max),\n                              SecantMethod())\n\nBroadcast example\n\nTo broadcast, wrap arguments that need not be broadcasted in a Ref.\n\njulia> using RootSolvers\nx_0 = rand(5,5)\nx_1 = rand(5,5).+2.0\nf(x, y) = x^2 - y\nx_star2 = 10000.0\nargs = Tuple(x_star2)\nx_star = sqrt(x_star2)\ntol_abs = 1.0e-3\niter_max = 100\nx_root, converged = find_zero.(f,\n                               x_0,\n                               x_1,\n                               Ref(args),\n                               Ref(IterParams(tol_abs, iter_max)),\n                               Ref(SecantMethod()))\n\n\n\n\n\n","category":"module"},{"location":"Utilities/RootSolvers/#CLIMA.RootSolvers.find_zero","page":"RootSolvers","title":"CLIMA.RootSolvers.find_zero","text":"find_zero(f, x_0, x_1, args, iter_params, SecantMethod)\n\nSolves the root equation, f, using Secant method. See RootSolvers for more information.\n\n\n\n\n\nfind_zero(f, x_0, x_1, args, iter_params, RegulaFalsiMethod)\n\nSolves the root equation, f, using Regula Falsi method. See RootSolvers for more information.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#MoistThermodynamics-Module-1","page":"MoistThermodynamics","title":"MoistThermodynamics Module","text":"","category":"section"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"The MoistThermodynamics module provides all thermodynamic functions needed for the atmosphere and functions shared across model components. The functions are general for a moist atmosphere that includes suspended cloud condensate in the working fluid; the special case of a dry atmosphere is obtained for zero specific humidities (or simply by omitting the optional specific humidity arguments in the functions that are needed for a dry atmosphere). The general formulation assumes that there are tracers for the total water specific humidity q_t, the liquid specific humidity q_l, and the ice specific humidity q_i to characterize the thermodynamic state and composition of moist air.","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"There are several types of functions:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Equation of state (ideal gas law):\nair_pressure\nSpecific gas constant and isobaric and isochoric specific heats of moist air:\ngas_constant_air\ncp_m\ncv_m\nSpecific latent heats of vaporization, fusion, and sublimation:\nlatent_heat_vapor\nlatent_heat_fusion\nlatent_heat_sublim\nSaturation vapor pressure and specific humidity over liquid and ice:\nsat_vapor_press_liquid\nsat_vapor_press_ice\nsat_shum\nFunctions computing energies and inverting them to obtain temperatures\ntotal_energy\ninternal_energy\nair_temperature\nFunctions to compute temperatures and partitioning of water into phases in thermodynamic equilibrium (when Gibbs' phase rule implies that the entire thermodynamic state of moist air, including the liquid and ice specific humidities, can be calculated from the 3 thermodynamic state variables, such as energy, pressure, and total specific humidity)\nliquid_fraction (fraction of condensate that is liquid)\nsaturation_adjustment (compute temperature from energy, density, and total specific humidity)\nAuxiliary functions for diagnostic purposes, e.g., other thermodynamic quantities\nliquid_ice_pottemp (liquid-ice potential temperature)","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"A moist dynamical core that assumes equilibrium thermodynamics can be obtained from a dry dynamical core with total energy as a prognostic variable by including a tracer for the total specific humidity q_t, using the functions, e.g., for the energies in the module, and computing the temperature T and the liquid and ice specific humidities q_l and q_i from the internal energy E_int by saturation adjustment:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"    T = saturation_adjustment(E_int, ρ, q_t, T_init);\n    phase_partitioning_eq!(q_l, q_i, T, ρ, q_t);","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"here, ρ is the density of the moist air, T_init is an initial temperature guess for the saturation adjustment iterations, and the internal energy E_int = E_tot - KE - geopotential is the total energy E_tot minus kinetic energy KE and potential energy geopotential (all energies per unit mass). No changes to the \"right-hand sides\" of the dynamical equations are needed for a moist dynamical core that supports clouds, as long as they do not precipitate. Additional source-sink terms arise from precipitation.","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"Schematically, the workflow in such a core would look as follows:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"\n    # initialize\n    geopotential = grav * z\n    T_prev       = ...\n    q_t          = ...\n    ρ            = ...\n\n    (u, v, w)    = ...\n    KE           = 0.5 * (u.^2 .+ v.^2 .+ w.^2)\n\n    E_tot        = total_energy(KE, geopotential, T, q_t)\n\n    do timestep   # timestepping loop\n\n      # advance dynamical variables by a timestep (temperature typically\n      # appears in terms on the rhs, such as radiative transfer)\n      advance(u, v, w, ρ, E_tot, q_t)  \n\n      # compute internal energy from dynamic variables\n      E_int = E_tot - 0.5 * (u.^2 .+ v.^2 .+ w.^2) - geopotential\n\n      # compute temperature, pressure and condensate specific humidities,\n      # using T_prev as initial condition for iterations\n      T = saturation_adjustment(E_int, ρ, q_t, T_prev);\n      phase_partitioning_eq!(q_l, q_i, T, ρ, q_t);\n      p = air_pressure(T, ρ, q_t, q_l, q_i)\n\n      # update temperature for next timestep\n      T_prev = T;  \n    end","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"For a dynamical core that additionally uses the liquid and ice specific humidities q_l and q_i as prognostic variables, and thus explicitly allows the presence of non-equilibrium phases such as supercooled water, the saturation adjustment in the above workflow is replaced by a direct calculation of temperature and pressure:","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"    T = air_temperature(E_int, q_t, q_l, q_i)\n    p = air_pressure(T, ρ, q_t, q_l, q_i)","category":"page"},{"location":"Utilities/MoistThermodynamics/#Functions-1","page":"MoistThermodynamics","title":"Functions","text":"","category":"section"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"CurrentModule = CLIMA.MoistThermodynamics","category":"page"},{"location":"Utilities/MoistThermodynamics/#","page":"MoistThermodynamics","title":"MoistThermodynamics","text":"gas_constant_air\nair_pressure\nair_density\ncp_m\ncv_m\nair_temperature\ninternal_energy\ninternal_energy_sat\ntotal_energy\nlatent_heat_vapor\nlatent_heat_sublim\nlatent_heat_fusion\nlatent_heat_generic\nsaturation_vapor_pressure\nsaturation_shum_generic\nsaturation_shum\nsaturation_shum_from_pressure\nliquid_fraction\nheaviside\nphase_partitioning_eq!\nsaturation_adjustment\nliquid_ice_pottemp","category":"page"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.gas_constant_air","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.gas_constant_air","text":"gas_constant_air([q_t=0, q_l=0, q_i=0])\n\nReturn the specific gas constant of moist air, given the total specific humidity q_t, and, optionally, the liquid specific humidity q_l, and the ice specific humidity q_i. When no input argument is given, it returns the specific gas constant of dry air.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.air_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_pressure","text":"air_pressure(T, ρ[, q_t=0, q_l=0, q_i=0])\n\nReturn the air pressure from the equation of state (ideal gas law), given the air temperature T, the (moist-)air density ρ, and, optionally, the total specific humidity q_t, the liquid specific humidity q_l, and the ice specific humidity q_i. Without the specific humidity arguments, it returns the air pressure from the equation of state of dry air.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.air_density","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_density","text":"air_density(T, p[, q_t=0, q_l=0, q_i=0])\n\nReturn the (moist-)air density from the equation of state (ideal gas law), given the air temperature T, the pressure p, and, optionally, the total specific humidity q_t, the liquid specific humidity q_l, and the ice specific humidity q_i. Without the specific humidity arguments, it returns the (moist-)air density from the equation of state of dry air.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.cp_m","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.cp_m","text":"cp_m([q_t=0, q_l=0, q_i=0])\n\nReturn the isobaric specific heat capacity of moist air, given the total water specific humidity q_t, liquid specific humidity q_l, and ice specific humidity q_i. Without the specific humidity arguments, it returns the isobaric specific heat capacity of dry air.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.cv_m","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.cv_m","text":"cv_m([q_t=0, q_l=0, q_i=0])\n\nReturn the isochoric specific heat capacity of moist air, given the total water specific humidity q_t, liquid specific humidity q_l, and ice specific humidity q_i. Without the specific humidity arguments, it returns the isochoric specific heat capacity of dry air.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.air_temperature","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.air_temperature","text":"air_temperature(e_int[, q_t=0, q_l=0, q_i=0])\n\nReturn the air temperature, given the internal energy e_int per unit mass, and, optionally, the total specific humidity q_t, the liquid specific humidity q_l, and the ice specific humidity q_i.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.internal_energy","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.internal_energy","text":"internal_energy(T[, q_t=0, q_l=0, q_i=0])\n\nReturn the internal energy per unit mass, given the temperature T, and, optionally, the total specific humidity q_t, the liquid specific humidity q_l, and the ice specific humidity q_i.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.internal_energy_sat","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.internal_energy_sat","text":"internal_energy_sat(T, ρ, q_t)\n\nReturn the internal energy per unit mass in thermodynamic equilibrium at saturation, given the temperature T, (moist-)air density ρ, and total specific humidity q_t.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.total_energy","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.total_energy","text":"total_energy(e_kin, e_pot, T[, q_t=0, q_l=0, q_i=0])\n\nReturn the total energy per unit mass, given the kinetic energy per unit mass e_kin, the potential energy per unit mass e_pot, the temperature T, and, optionally, the total specific humidity q_t, the liquid specific humidity q_l, and the ice specific humidity q_i.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.latent_heat_vapor","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_vapor","text":"latent_heat_vapor(T)\n\nReturn the specific latent heat of vaporization at temperature T.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.latent_heat_sublim","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_sublim","text":"latent_heat_sublim(T)\n\nReturn the specific latent heat of sublimation at temperature T.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.latent_heat_fusion","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_fusion","text":"latent_heat_fusion(T)\n\nReturn the specific latent heat of fusion at temperature T.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.latent_heat_generic","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.latent_heat_generic","text":"latent_heat_generic(T, LH_0, cp_diff)\n\nReturn the specific latent heat of a generic phase transition between two phases using Kirchhoff's relation.\n\nThe latent heat computation assumes constant isobaric specifc heat capacities of the two phases. T is the temperature, LH_0 is the latent heat of the phase transition at T_0, and cp_diff is the difference between the isobaric specific heat capacities (heat capacity in the higher-temperature phase minus that in the lower-temperature phase).\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_vapor_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_vapor_pressure","text":"`saturation_vapor_pressure(T, Liquid())`\n\nReturn the saturation vapor pressure over a plane liquid surface at temperature T.\n\n`saturation_vapor_pressure(T, Ice())`\n\nReturn the saturation vapor pressure over a plane ice surface at temperature T.\n\n`saturation_vapor_pressure(T, LH_0, cp_diff)`\n\nCompute the saturation vapor pressure over a plane surface by integration of the Clausius-Clepeyron relation.\n\nThe Clausius-Clapeyron relation\n\ndlog(p_vs)/dT = [LH_0 + cp_diff * (T-T_0)]/(R_v*T^2)\n\nis integrated from the triple point temperature T_triple, using Kirchhoff's relation\n\nL = LH_0 + cp_diff * (T - T_0)\n\nfor the specific latent heat L with constant isobaric specific heats of the phases. The linear dependence of the specific latent heat on temperature T allows analytic integration of the Clausius-Clapeyron relation to obtain the saturation vapor pressure p_vs as a function of the triple point pressure press_triple.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_shum_generic","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_shum_generic","text":"saturation_shum_generic(T, ρ[; phase=Liquid()])\n\nCompute the saturation specific humidity over a plane surface of condensate, given the temperature T and the (moist-)air density ρ.\n\nThe optional argument phase can be Liquid() or ice and indicates the condensed phase.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_shum","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_shum","text":"saturation_shum(T, ρ[, q_l=0, q_i=0])\n\nCompute the saturation specific humidity, given the temperature T and (moist-)air density ρ.\n\nIf the optional liquid, and ice specific humdities q_t and q_l are given, the saturation specific humidity is that over a mixture of liquid and ice, computed in a thermodynamically consistent way from the weighted sum of the latent heats of the respective phase transitions (Pressel et al., JAMES, 2015). That is, the saturation vapor pressure and from it the saturation specific humidity are computed from a weighted mean of the latent heats of vaporization and sublimation, with the weights given by the fractions of condensate q_l/(q_l + q_i) and q_i/(q_l + q_i) that are liquid and ice, respectively.\n\nIf the condensate specific humidities q_l and q_i are not given or are both zero, the saturation specific humidity is that over a mixture of liquid and ice, with the fraction of liquid given by temperature dependent liquid_fraction(T) and the fraction of ice by the complement 1 - liquid_fraction(T).\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_shum_from_pressure","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_shum_from_pressure","text":"saturation_shum_from_pressure(T, ρ, p_vs)\n\nCompute the saturation specific humidity, given the ambient air temperature T, density ρ, and the saturation vapor pressure p_vs.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.liquid_fraction","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_fraction","text":"liquid_fraction(T[, q_l=0, q_i=0])\n\nReturn the fraction of condensate that is liquid.\n\nIf the optional input arguments q_l and q_i are not given or are zero, the fraction of liquid is a function that is 1 above T_freeze and goes to zero below T_freeze. If q_l or q_i are nonzero, the liquid fraction is computed from them.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.heaviside","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.heaviside","text":"heaviside(t)\n\nReturn the Heaviside step function at t.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.phase_partitioning_eq!","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.phase_partitioning_eq!","text":"phase_partitioning_eq!(q_l, q_i, T, ρ, q_t)\n\nReturn the partitioning of the phases in equilibrium.\n\nGiven the temperature T and (moist-)air density ρ, phase_partitioning_eq! partitions the total specific humidity q_t into the liquid specific humidity q_l and ice specific humiditiy q_l using the liquid_fraction function. The residual q_t - q_l - q_i is the vapor specific humidity.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.saturation_adjustment","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.saturation_adjustment","text":"saturation_adjustment(e_int, ρ, q_t[, T_init = T_triple])\n\nReturn the temperature that is consistent with the internal energy e_int, (moist-)air density ρ, and total specific humidity q_t.\n\nThe optional input value of the temperature T_init is taken as the initial value of the saturation adjustment iterations.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/MoistThermodynamics/#CLIMA.MoistThermodynamics.liquid_ice_pottemp","page":"MoistThermodynamics","title":"CLIMA.MoistThermodynamics.liquid_ice_pottemp","text":"liquid_ice_pottemp(T, p[, q_t=0, q_l=0, q_i=0])\n\nReturn the liquid-ice potential temperature, given the temperature T, pressure p, total specific humidity q_t, liquid specific humidity q_l, and ice specific humidity q_i.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#SurfaceFluxes-1","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"CurrentModule = CLIMA.SurfaceFluxes","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Surface flux functions, e.g. for buoyancy flux, friction velocity, and exchange coefficients.","category":"page"},{"location":"Atmos/SurfaceFluxes/#Byun1990-1","page":"SurfaceFluxes","title":"Byun1990","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Compute surface fluxes using the approach in Byun (1990).","category":"page"},{"location":"Atmos/SurfaceFluxes/#Plots-1","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using CLIMA.SurfaceFluxes.Byun1990\nusing Plots, LaTeXStrings\n\nRi_range = range(-1.2, stop=0.24, length=100)\nscales = [50,200,600,1000,10_000]\n\nz_0 = 1.0\nγ_m, γ_h = 15.0, 9.0\nβ_m, β_h = 4.8, 7.8\nPr_0 = 0.74\n\nplot(Ri_range,\n    [Byun1990.compute_exchange_coefficients(Ri,scale*z_0,z_0,γ_m,γ_h,β_m,β_h,Pr_0)[1]\n        for Ri in Ri_range, scale in scales], \n    xlabel=\"Bulk Richardson number (Ri_b)\", ylabel=\"Drag coefficient\", title=\"Momentum exchange coefficient\",\n    labels=scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4a.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(a) from Byun (1990)","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"plot(Ri_range,\n    [Byun1990.compute_exchange_coefficients(Ri,scale*z_0,z_0,γ_m,γ_h,β_m,β_h,Pr_0)[2]\n        for Ri in Ri_range, scale in scales], \n    xlabel=\"Bulk Richardson number (Ri_b)\", ylabel=\"Exchange coefficient\", title=\"Heat exchange coefficient\",\n    labels=scales, legendtitle=L\"z/z_0\")\n\nsavefig(\"exchange_byun1990_fig4b.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Recreation of Figure 4(b) from Byun (1990)","category":"page"},{"location":"Atmos/SurfaceFluxes/#Nishizawa2018-1","page":"SurfaceFluxes","title":"Nishizawa2018","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#Plots-2","page":"SurfaceFluxes","title":"Plots","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"using CLIMA.SurfaceFluxes.Nishizawa2018\nusing Plots, LaTeXStrings\n\na = 4.7\nθ = 350\nz_0 = 10\nu_ave = 10\nΔz = range(10.0, stop=100.0, length=100)\nΨ_m_tol, tol_abs, iter_max = 1e-3, 1e-3, 10\nu_star = Nishizawa2018.compute_friction_velocity.(\n    u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\nplot(u_star, Δz, title = \"Friction velocity vs dz\", xlabel = \"Friction velocity\", ylabel = \"dz\")\nsavefig(\"friction_velocity.svg\") # hide\nnothing # hide","category":"page"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"(Image: )","category":"page"},{"location":"Atmos/SurfaceFluxes/#API-1","page":"SurfaceFluxes","title":"API","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"compute_buoyancy_flux\nByun1990.compute_MO_len\nByun1990.compute_friction_velocity\nByun1990.compute_exchange_coefficients\nNishizawa2018.compute_MO_len\nNishizawa2018.compute_friction_velocity\nNishizawa2018.compute_exchange_coefficients","category":"page"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.compute_buoyancy_flux","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.compute_buoyancy_flux","text":"compute_buoyancy_flux(shf, lhf, T_b, qt_b, ql_b, qi_b, alpha0_0)\n\nComputes buoyancy flux given sensible heat flux shf, latent heat flux lhf, surface boundary temperature T_b, total specific humidity qt_b, liquid specific humidity ql_b, ice specific humidity qi_b and specific alpha0_0.\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Byun1990.compute_MO_len","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_MO_len","text":"compute_MO_len(u, flux)\n\nComputes the Monin-Obukhov length (Eq. 3 Ref. Byun1990)\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Byun1990.compute_friction_velocity","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_friction_velocity","text":"compute_friction_velocity(u_ave, flux, z_0, z_1, β_m, γ_m, tol_abs, iter_max)\n\nComputes roots of friction velocity equation (Eq. 10 in Ref. Byun1990)\n\nu_ave = u_* ( ln(z/z_0) - ψ_m(z/L, z_0/L) ) /κ        Eq. 10 in Ref. Byun1990\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Byun1990.compute_exchange_coefficients","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Byun1990.compute_exchange_coefficients","text":"compute_exchange_coefficients(Ri, z_b, z_0, γ_m, γ_h, β_m, β_h, Pr_0)\n\nComputes exchange transfer coefficients:\n\nC_D  momentum exchange coefficient      (Eq. 36)\nC_H  thermodynamic exchange coefficient (Eq. 37)\nL_mo Monin-Obukhov length               (re-arranged Eq. 3)\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Nishizawa2018.compute_MO_len","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_MO_len","text":"compute_MO_len(u, θ, flux)\n\nComputes Monin-Obukhov length. Eq. 3 Ref. Nishizawa2018\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_friction_velocity","text":"compute_friction_velocity(u_ave, θ, flux, Δz, z_0, a, Ψ_m_tol, tol_abs, iter_max)\n\nComputes friction velocity, in Eq. 12 in Ref. Nishizawa2018, by solving the non-linear equation:\n\nu_ave = ustar/κ * ( ln(Δz/z_0) - Ψ_m(Δz/L) + z_0/Δz * Ψ_m(z_0/L) + R_z0 [ψ_m(z_0/L) - 1] )\n\nwhere L is a non-linear function of ustar (see compute_MO_len).\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#CLIMA.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","page":"SurfaceFluxes","title":"CLIMA.SurfaceFluxes.Nishizawa2018.compute_exchange_coefficients","text":"compute_exchange_coefficients(z, F_m, F_h, a, u_star, θ, flux, Pr)\n\nComputes exchange transfer coefficients:\n\nK_D  momentum exchange coefficient\nK_H  thermodynamic exchange coefficient\nL_mo Monin-Obukhov length\n\n\n\n\n\n","category":"function"},{"location":"Atmos/SurfaceFluxes/#References-1","page":"SurfaceFluxes","title":"References","text":"","category":"section"},{"location":"Atmos/SurfaceFluxes/#","page":"SurfaceFluxes","title":"SurfaceFluxes","text":"Businger, Joost A., et al. \"Flux-profile relationships in the atmospheric surface layer.\" Journal of the atmospheric Sciences 28.2 (1971): 181-189. doi: 10.1175/1520-0469(1971)028<0181:FPRITA>2.0.CO;2\nNishizawa, S., and Y. Kitamura. \"A Surface Flux Scheme Based on the Monin-Obukhov Similarity for Finite Volume Models.\" Journal of Advances in Modeling Earth Systems 10.12 (2018): 3159-3175. doi: 10.1029/2018MS001534\nByun, Daewon W. \"On the analytical solutions of flux-profile relationships for the atmospheric surface layer.\" Journal of Applied Meteorology 29.7 (1990): 652-657.   doi: 10.1175/1520-0450(1990)029<0652:OTASOF>2.0.CO;2\nWyngaard, John C. \"Modeling the planetary boundary layer-Extension to the stable case.\" Boundary-Layer Meteorology 9.4 (1975): 441-460. doi: 10.1007/BF00223393","category":"page"},{"location":"ODESolvers/#ODESolvers-1","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"ODESolvers/#LowStorageRungeKutta-1","page":"ODESolvers","title":"LowStorageRungeKutta","text":"","category":"section"},{"location":"ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"LowStorageRungeKuttaMethod.LowStorageRungeKutta\nLowStorageRungeKuttaMethod.updatedt!","category":"page"},{"location":"ODESolvers/#GenericCallbacks-1","page":"ODESolvers","title":"GenericCallbacks","text":"","category":"section"},{"location":"ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"GenericCallbacks.EveryXWallTimeSeconds\nGenericCallbacks.EveryXSimulationSteps","category":"page"},{"location":"ODESolvers/#ODESolvers-2","page":"ODESolvers","title":"ODESolvers","text":"","category":"section"},{"location":"ODESolvers/#","page":"ODESolvers","title":"ODESolvers","text":"ODESolvers.solve!","category":"page"},{"location":"Mesh/#Meshing-Stuff-1","page":"Mesh","title":"Meshing Stuff","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"CurrentModule = CLIMA","category":"page"},{"location":"Mesh/#Topologies-1","page":"Mesh","title":"Topologies","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.","category":"page"},{"location":"Mesh/#Types-1","page":"Mesh","title":"Types","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Topologies.AbstractTopology\nTopologies.BoxElementTopology\nTopologies.BrickTopology\nTopologies.StackedBrickTopology\nTopologies.CubedShellTopology\nTopologies.StackedCubedSphereTopology","category":"page"},{"location":"Mesh/#CLIMA.Topologies.AbstractTopology","page":"Mesh","title":"CLIMA.Topologies.AbstractTopology","text":"AbstractTopology{dim}\n\nRepresents the connectivity of individual elements, with local dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.BoxElementTopology","page":"Mesh","title":"CLIMA.Topologies.BoxElementTopology","text":"BoxElementTopology{dim, T} <: AbstractTopology{dim}\n\nThe local topology of a larger MPI-distributed topology, represented by dim-dimensional box elements.\n\nThis contains the necessary information for the connectivity elements of the elements on the local process, along with \"ghost\" elements from neighbouring processes.\n\nFields\n\nmpicomm\nMPI communicator for communicating with neighbouring processes.\n\nelems\nRange of element indices\n\nrealelems\nRange of real (aka nonghost) element indices\n\nghostelems\nRange of ghost element indices\n\nsendelems\nArray of send element indices sorted so that\n\nelemtocoord\nElement to vertex coordinates; elemtocoord[d,i,e] is the dth coordinate of corner i of element e\nnote: Note\ncurrently coordinates always are of size 3 for (x, y, z)\n\nelemtoelem\nElement to neighboring element; elemtoelem[f,e] is the number of the element neighboring element e across face f.  If there is no neighboring element then elemtoelem[f,e] == e.\n\nelemtoface\nElement to neighboring element face; elemtoface[f,e] is the face number of the element neighboring element e across face f.  If there is no neighboring element then elemtoface[f,e] == f.\"\n\nelemtoordr\nelement to neighboring element order; elemtoordr[f,e] is the ordering number of the element neighboring element e across face f.  If there is no neighboring element then elemtoordr[f,e] == 1.\n\nelemtobndy\nElement to bounday number; elemtobndy[f,e] is the boundary number of face f of element e.  If there is a neighboring element then elemtobndy[f,e] == 0.\n\nnabrtorank\nList of the MPI ranks for the neighboring processes\n\nnabrtorecv\nRange in ghost elements to receive for each neighbor\n\nnabrtosend\nRange in sendelems to send for each neighbor\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.BrickTopology","page":"Mesh","title":"CLIMA.Topologies.BrickTopology","text":"BrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topolgy. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.StackedBrickTopology","page":"Mesh","title":"CLIMA.Topologies.StackedBrickTopology","text":"StackedBrickTopology{dim, T} <: AbstractTopology{dim}\n\nA simple grid-based topolgy, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.CubedShellTopology","page":"Mesh","title":"CLIMA.Topologies.CubedShellTopology","text":"CubedShellTopology{T} <: AbstractTopology{2}\n\nA cube-shell topolgy. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#CLIMA.Topologies.StackedCubedSphereTopology","page":"Mesh","title":"CLIMA.Topologies.StackedCubedSphereTopology","text":"StackedCubedSphereTopology{3, T} <: AbstractTopology{3}\n\nA cube-sphere topology. All elements on the same \"vertical\" dimension are stacked to be contiguous. This is a convenience wrapper around BoxElementTopology.\n\n\n\n\n\n","category":"type"},{"location":"Mesh/#Functions-1","page":"Mesh","title":"Functions","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Topologies.cubedshellmesh\nTopologies.cubedshellwarp","category":"page"},{"location":"Mesh/#CLIMA.Topologies.cubedshellmesh","page":"Mesh","title":"CLIMA.Topologies.cubedshellmesh","text":"cubedshellmesh(T, Ne; part=1, numparts=1)\n\nGenerate a cubed mesh with each of the \"cubes\" has an Ne X Ne grid of elements.\n\nThe mesh can optionally be partitioned into numparts and this returns partition part.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.\n\nThis mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.\n\nThe mesh structures for the cubes is as follows:\n\nx_2\n   ^\n   |\n4Ne-           +-------+\n   |           |       |\n   |           |   6   |\n   |           |       |\n3Ne-           +-------+\n   |           |       |\n   |           |   5   |\n   |           |       |\n2Ne-           +-------+\n   |           |       |\n   |           |   4   |\n   |           |       |\n Ne-   +-------+-------+-------+\n   |   |       |       |       |\n   |   |   1   |   2   |   3   |\n   |   |       |       |       |\n  0-   +-------+-------+-------+\n   |\n   +---|-------|-------|------|-> x_1\n       0      Ne      2Ne    3Ne\n\n\n\n\n\n","category":"function"},{"location":"Mesh/#CLIMA.Topologies.cubedshellwarp","page":"Mesh","title":"CLIMA.Topologies.cubedshellwarp","text":"cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))\n\nGiven points (a, b, c) on the surface of a cube, warp the points out to a spherical shell of radius R based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) https://dx.doi.org/10.1006/jcph.1996.0047\n\n@article{RonchiIaconoPaolucci1996,\n  title={The ``cubed sphere'': a new method for the solution of partial\n         differential equations in spherical geometry},\n  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},\n  journal={Journal of Computational Physics},\n  volume={124},\n  number={1},\n  pages={93--114},\n  year={1996},\n  doi={10.1006/jcph.1996.0047}\n}\n\n\n\n\n\n","category":"function"},{"location":"Mesh/#Grids-1","page":"Mesh","title":"Grids","text":"","category":"section"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Grids specify the approximation within each element, and any necessary warping.","category":"page"},{"location":"Mesh/#","page":"Mesh","title":"Mesh","text":"Grids.DiscontinuousSpectralElementGrid","category":"page"},{"location":"Mesh/#CLIMA.Grids.DiscontinuousSpectralElementGrid","page":"Mesh","title":"CLIMA.Grids.DiscontinuousSpectralElementGrid","text":"DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,\n                                 polynomialorder,\n                                 meshwarp = (x...)->identity(x))\n\nGenerate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a topology, where the order of the elements is given by polynomialorder. DeviceArray gives the array type used to store the data (CuArray or Array), and the coordinate points will be of FloatType.\n\nThe optional meshwarp function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.\n\n\n\n\n\n","category":"type"},{"location":"AtmosDycore/#CLIMAAtmosDycore-1","page":"AtmosDycore","title":"CLIMAAtmosDycore","text":"","category":"section"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"CurrentModule = CLIMA.CLIMAAtmosDycore","category":"page"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"getrhsfunction","category":"page"},{"location":"AtmosDycore/#CLIMA.CLIMAAtmosDycore.getrhsfunction","page":"AtmosDycore","title":"CLIMA.CLIMAAtmosDycore.getrhsfunction","text":"getrhsfunction(disc::AbstractAtmosDiscretization)\n\nThe spatial discretizations are of the form Q = f(Q), and this function returns the handle to right-hand side function f of the disc\n\n\n\n\n\n","category":"function"},{"location":"AtmosDycore/#VanillaAtmosDiscretizations-1","page":"AtmosDycore","title":"VanillaAtmosDiscretizations","text":"","category":"section"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"A discretization adds additional information for the atmosphere problem.","category":"page"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"VanillaAtmosDiscretizations.VanillaAtmosDiscretization\nVanillaAtmosDiscretizations.estimatedt","category":"page"},{"location":"AtmosDycore/#CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.VanillaAtmosDiscretization","page":"AtmosDycore","title":"CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.VanillaAtmosDiscretization","text":"VanillaAtmosDiscretization{nmoist, ntrace}(grid; gravity = true,\nviscosity = 0)\n\nGiven a 'grid <: AbstractGrid' this construct all the data necessary to run a vanilla discontinuous Galerkin discretization of the the compressible Euler equations with nmoist moisture variables and ntrace tracer variables. If the boolean keyword argument gravity is true then gravity is used otherwise it is not. Isotropic viscosity can be used if viscosity is set to a positive constant.\n\n\n\n\n\n","category":"type"},{"location":"AtmosDycore/#CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.estimatedt","page":"AtmosDycore","title":"CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.estimatedt","text":"estimatedt(disc::VanillaAtmosDiscretization, Q::MPIStateArray)\n\nGiven a discretization disc and a state Q compute an estimate for the time step\n\ntodo: Todo\nThis estimate is currently very conservative, needs to be revisited\n\n\n\n\n\n","category":"function"},{"location":"AtmosDycore/#AtmosStateArray-1","page":"AtmosDycore","title":"AtmosStateArray","text":"","category":"section"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"Storage for the state of a discretization.","category":"page"},{"location":"AtmosDycore/#","page":"AtmosDycore","title":"AtmosDycore","text":"AtmosStateArrays.AtmosStateArray\nAtmosStateArrays.postrecvs!\nAtmosStateArrays.startexchange!\nAtmosStateArrays.finishexchange!","category":"page"},{"location":"TurbulenceConvection/#TurbulenceConvection-1","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"","category":"section"},{"location":"TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"CurrentModule = CLIMA.TurbulenceConvection","category":"page"},{"location":"TurbulenceConvection/#Grids-1","page":"TurbulenceConvection","title":"Grids","text":"","category":"section"},{"location":"TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"Grids.Grid\nGrids.over_elems\nGrids.over_elems_real\nGrids.over_elems_ghost\nGrids.first_elem_above_surface\nGrids.get_z","category":"page"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.Grid","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.Grid","text":"Grid{T}\n\nA simple 1-dimensional uniform grid of type T for finite difference method.\n\n\n\n\n\n","category":"type"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.over_elems","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.over_elems","text":"over_elems(grid::Grid)\n\nGet the range of indexes to traverse real and ghost grid elements\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.over_elems_real","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.over_elems_real","text":"over_elems_real(grid::Grid)\n\nGet the range of indexes to traverse only real grid elements\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.over_elems_ghost","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.over_elems_ghost","text":"over_elems_ghost(grid::Grid)\n\nGet the range of indexes to traverse only ghost grid elements\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.first_elem_above_surface","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.first_elem_above_surface","text":"first_elem_above_surface(grid::Grid)\n\nGet the first element index above the surface\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.Grids.get_z","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.Grids.get_z","text":"get_z(grid::Grid, k::Int)\n\nGet the z-coordinate given element index\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#Grid-Operators-1","page":"TurbulenceConvection","title":"Grid Operators","text":"","category":"section"},{"location":"TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"GridOperators.∇_z\nGridOperators.Δ_z\nGridOperators.adv_upwind","category":"page"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.GridOperators.∇_z","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.GridOperators.∇_z","text":"∇_z(f, grid::Grid)\n\nComputes the local derivative of field f\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.GridOperators.Δ_z","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.GridOperators.Δ_z","text":"Δ_z(f, grid::Grid)\n\nComputes the local Laplacian of field f\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.GridOperators.adv_upwind","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.GridOperators.adv_upwind","text":"adv_upwind(ϕ, u, grid::Grid)\n\nLocal upwind advection operator u⋅∇ϕ. This operator is stable but numerically diffusive.\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#State-Vector-1","page":"TurbulenceConvection","title":"State Vector","text":"","category":"section"},{"location":"TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"StateVecs.StateVec\nStateVecs.over_sub_domains\nStateVecs.Slice","category":"page"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecs.StateVec","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.StateVec","text":"StateVec{T, I, NT}\n\nA state vector containing the number of subdomains, n_subdomains, a NamedTuple variable mapper, a tuple of the variable names, and a vector of vectors, containing the values for all of the variables.\n\n\n\n\n\n","category":"type"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecs.over_sub_domains","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.over_sub_domains","text":"over_sub_domains(state_vec::StateVec)\n\nGet list of indexes from 1 to the maximum subdomain size.\n\n\n\n\n\nover_sub_domains(state_vec::StateVec, j::Int)\n\nGet list of indexes from 1 to the maximum subdomain size, except the given index.\n\n\n\n\n\nover_sub_domains(state_vec::StateVec, name::Symbol)\n\nGet list of indexes over all subdomains for variable name.\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.StateVecs.Slice","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.StateVecs.Slice","text":"Slice{I} <: AbstractSlice{I}\n\nA slice struct used to slice the state vector along the grid-element dimension. This is used to as an API to pass slices into local derivative/interpolation routines.\n\n\n\n\n\n","category":"type"},{"location":"TurbulenceConvection/#Boundary-Conditions-1","page":"TurbulenceConvection","title":"Boundary Conditions","text":"","category":"section"},{"location":"TurbulenceConvection/#","page":"TurbulenceConvection","title":"TurbulenceConvection","text":"BoundaryConditions.Dirichlet!\nBoundaryConditions.Neumann!\nBoundaryConditions.Top\nBoundaryConditions.Bottom","category":"page"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Dirichlet!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Dirichlet!","text":"Dirichlet!(sv::StateVec, name::Symbol, val, grid, ::Bottom, i_sd=1)\n\nApply Dirichlet boundary conditions at the bottom of the domain\n\n\n\n\n\nDirichlet!(sv::StateVec, name::Symbol, val, grid, ::Top, i_sd=1)\n\nApply Dirichlet boundary conditions at the bottom of the domain\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Neumann!","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Neumann!","text":"Neumann!(sv::StateVec, name::Symbol, val, grid, ::Bottom, i_sd=1)\n\nApply Neumann boundary conditions at the bottom of the domain\n\n\n\n\n\nNeumann!(sv::StateVec, name::Symbol, val, grid, ::Top, i_sd=1)\n\nApply Neumann boundary conditions at the bottom of the domain\n\n\n\n\n\n","category":"function"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Top","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Top","text":"Top<:BoundaryLocation\n\nLocation to apply boundary condition\n\n\n\n\n\n","category":"type"},{"location":"TurbulenceConvection/#CLIMA.TurbulenceConvection.BoundaryConditions.Bottom","page":"TurbulenceConvection","title":"CLIMA.TurbulenceConvection.BoundaryConditions.Bottom","text":"Bottom<:BoundaryLocation\n\nLocation to apply boundary condition\n\n\n\n\n\n","category":"type"},{"location":"CodingConventions/#Coding-Conventions-1","page":"Coding Conventions","title":"Coding Conventions","text":"","category":"section"},{"location":"CodingConventions/#","page":"Coding Conventions","title":"Coding Conventions","text":"A list of recommended coding conventions.","category":"page"},{"location":"CodingConventions/#","page":"Coding Conventions","title":"Coding Conventions","text":"There are good recommendations in the Julia style-guide:\nhttps://docs.julialang.org/en/v1/manual/style-guide/index.html\nhttps://docs.julialang.org/en/v0.6/manual/packages/#Guidelines-for-naming-a-package-1\nPlease only use Unicode characters that are within our list of acceptable Unicode characters (in AcceptableUnicode.md).\nModules, and class names (structs), should follow TitleCase convention. Note that class names cannot coincide with module names.\nFunction names should be lowercase, with words separated by underscores as necessary to improve readability.\nVariable names follow the same convention as function names. Follow CMIP conventions (http://clipc-services.ceda.ac.uk/dreq/) where possible and practicable.\nMake names consistent, distinctive, and meaningful.\nDocument design and purpose, rather than mechanics and implementation (document interfaces and embed documentation in code).\nAvoid variable names that coincide with module and class names, as well as function/variable names that are natively supported.\nNever use the characters 'l' (lowercase letter el), 'O' (uppercase letter oh), or 'I' (uppercase letter eye) as single character variable names.\nTwo white spaces are used for indent. This is not part of the standard convention, but recent development efforts have been using this indentation style (e.g., Google's Tensorflow), and this style is being used here also.\nKISS (keep it simple stupid).\nTry to limit all lines to a maximum of 79 characters.\nSingle access point - if a variable/constant is defined more than once, then move it into a module and import (or \"using\") to that module to access the variable in order to enforce a single access point (to avoid consistency issues). Any time a chunk of code is used more than once, or when several similar versions exist across the codebase, consider generalizing this functionality and using a new function to avoid replicating code\n\"import\"/\"using\" should be grouped in the following order:\nStandard library imports.\nRelated third party imports.\nLocal application/library specific imports.\nUse a blank line between each group of imports.","category":"page"},{"location":"CodingConventions/#Why-do-we-limit-our-Unicode-use?-1","page":"Coding Conventions","title":"Why do we limit our Unicode use?","text":"","category":"section"},{"location":"CodingConventions/#","page":"Coding Conventions","title":"Coding Conventions","text":"Some characters are visibly indistinguishable. Capital \"a\" and capital alpha are visibly indistinguishable, but are recognized as separate characters (e.g., search distinguishable).\nSome characters are difficult to read. Sometimes, the overline/overdot/hats overlap with characters making them difficult to see.\nPortability issues. Unicode does not render in Jupyter notebook natively (on OSX).\nIf it does improve readability enough, and are not worried about portability, we may introduce a list of permissible characters that are commonly used.","category":"page"},{"location":"AcceptableUnicode/#Acceptable-Unicode-characters:-1","page":"Acceptable Unicode characters:","title":"Acceptable Unicode characters:","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters:","title":"Acceptable Unicode characters:","text":"Using Unicode seems to be irresistible. However, we must ensure avoiding problematic Unicode usage.","category":"page"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters:","title":"Acceptable Unicode characters:","text":"Below is a list of acceptable Unicode characters. All characters not listed below are forbidden. We forbid the use of accents (dot, hat, vec, etc.), because this can lead to visually ambiguous characters.","category":"page"},{"location":"AcceptableUnicode/#Acceptable-lower-case-Greek-letters:-1","page":"Acceptable Unicode characters:","title":"Acceptable lower-case Greek letters:","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters:","title":"Acceptable Unicode characters:","text":"α # (alpha)\nβ # (beta)\nδ # (delta)\nϵ # (epsilon)\nε # (varepsilon)\nγ # (gamma)\nκ # (kappa)\nλ # (lambda)\nμ # (mu)\nν # (nu)\nη # (eta)\nω # (omega)\nπ # (pi)\nρ # (rho)\nσ # (sigma)\nθ # (theta)\nχ # (chi)\nξ # (xi)\nζ # (zeta)\nϕ # (psi)\nφ # (varphi)","category":"page"},{"location":"AcceptableUnicode/#Acceptable-upper-case-Greek-letters:-1","page":"Acceptable Unicode characters:","title":"Acceptable upper-case Greek letters:","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters:","title":"Acceptable Unicode characters:","text":"Δ # (Delta)\n∑ # (Sigma)\nΓ # (Gamma)\nΩ # (Omega)\nΨ # (Psi)\n<!-- Φ # (Phi) removed in favor of lowercase psi -->","category":"page"},{"location":"AcceptableUnicode/#Acceptable-mathematical-symbols:-1","page":"Acceptable Unicode characters:","title":"Acceptable mathematical symbols:","text":"","category":"section"},{"location":"AcceptableUnicode/#","page":"Acceptable Unicode characters:","title":"Acceptable Unicode characters:","text":"∫ # (int)\n∬ # (iint)\n∭ # (iiint)\n∞ # (infinity)\n≈ # (approx)\n∂ # (partial)\n∇ # (nabla/del), note that nabla and del are indistinguishable\n∀ # (forall)\n≥ # (greater than equal to)\n≤ # (less than equal to)\n<!-- ∈ # (in) removed in favor of epsilon -->","category":"page"}]
}

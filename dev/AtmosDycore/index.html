<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CLIMAAtmosDycore · CLIMA</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="CLIMA logo"/></a><h1>CLIMA</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../Utilities/"><code>Utilities</code></a></li><li class="current"><a class="toctext" href>CLIMAAtmosDycore</a><ul class="internal"><li><a class="toctext" href="#AtmosStateArray-1"><code>AtmosStateArray</code></a></li><li><a class="toctext" href="#Grids-1"><code>Grids</code></a></li><li><a class="toctext" href="#Topologies-1"><code>Topologies</code></a></li><li><a class="toctext" href="#VanillaAtmosDiscretizations-1"><code>VanillaAtmosDiscretizations</code></a></li><li><a class="toctext" href="#LSRKmethods-1"><code>LSRKmethods</code></a></li></ul></li></ul></li><li><span class="toctext">Developer docs</span><ul><li><a class="toctext" href="../CodingConventions/">Coding Conventions</a></li><li><a class="toctext" href="../AcceptableUnicode/">Acceptable Unicode characters:</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modules</li><li><a href>CLIMAAtmosDycore</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/CLIMA/blob/master/docs/src/AtmosDycore.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>CLIMAAtmosDycore</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CLIMAAtmosDycore-1" href="#CLIMAAtmosDycore-1">CLIMAAtmosDycore</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.getrhsfunction" href="#CLIMA.CLIMAAtmosDycore.getrhsfunction"><code>CLIMA.CLIMAAtmosDycore.getrhsfunction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getrhsfunction(disc::AbstractAtmosDiscretization)</code></pre><p>The spatial discretizations are of the form <span>$Q̇ = f(Q)$</span>, and this function returns the handle to right-hand side function <span>$f$</span> of the <code>disc</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/CLIMAAtmosDycore.jl#L9-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.solve!" href="#CLIMA.CLIMAAtmosDycore.solve!"><code>CLIMA.CLIMAAtmosDycore.solve!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve!(Q, solver::AbstractAtmosODESolver; timeend,
       stopaftertimeend=true, numberofsteps, callbacks)</code></pre><p>Solves an ODE using the <code>solver</code> starting from a state <code>Q</code>. The state <code>Q</code> is updated inplace. The final time <code>timeend</code> or <code>numberofsteps</code> must be specified.</p><p>A series of optional callback functions can be specified using the tuple <code>callbacks</code>; see <a href="@ref"><code>GenericCallbacks</code></a>.</p><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>Currently <code>stopaftertimeend</code> is not used. The idea behind it was that a user might want to stop either one step before or after the final time <code>timeend</code>. This should either be removed or used.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/CLIMAAtmosDycore.jl#L22-L37">source</a></section><h2><a class="nav-anchor" id="AtmosStateArray-1" href="#AtmosStateArray-1"><code>AtmosStateArray</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.AtmosStateArrays.AtmosStateArray" href="#CLIMA.CLIMAAtmosDycore.AtmosStateArrays.AtmosStateArray"><code>CLIMA.CLIMAAtmosDycore.AtmosStateArrays.AtmosStateArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AtmosStateArray{S &lt;: Tuple, T, DeviceArray, N,
                DATN&lt;:AbstractArray{T,N}, Nm1, DAI1} &lt;: AbstractArray{T, N}</code></pre><p><code>N</code>-dimensional MPI-aware array with elements of type <code>T</code>. The dimension <code>N</code> is <code>length(S) + 1</code>. <code>S</code> is a tuple of the first <code>N-1</code> array dimensions.</p><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>It should be reevaluated whether all this stuff in the type domain is really necessary (some of it was optimistically added for functionality that never panned out)</p></div></div><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>tag for the MPI message should probably be unified for each <code>AtmosStateArray</code> (right now <code>888</code> used is the same for all communication)</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/AtmosStateArrays.jl#L8-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.AtmosStateArrays.postrecvs!" href="#CLIMA.CLIMAAtmosDycore.AtmosStateArrays.postrecvs!"><code>CLIMA.CLIMAAtmosDycore.AtmosStateArrays.postrecvs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">postrecvs!(Q::AtmosStateArray)</code></pre><p>posts the <code>MPI.Irecv!</code> for <code>Q</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/AtmosStateArrays.jl#L176-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.AtmosStateArrays.startexchange!" href="#CLIMA.CLIMAAtmosDycore.AtmosStateArrays.startexchange!"><code>CLIMA.CLIMAAtmosDycore.AtmosStateArrays.startexchange!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">startexchange!(Q::AtmosStateArray; dorecvs=true)</code></pre><p>Start the MPI exchange of the data stored in <code>Q</code>. If <code>dorecvs</code> is <code>true</code> then <code>postrecvs!(Q)</code> is called, otherwise the caller is responsible for this.</p><p>This function will fill the send buffer (on the device), copies the data from the device to the host, and then issues the send. Previous sends are waited on to ensure that they are complete.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/AtmosStateArrays.jl#L192-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.AtmosStateArrays.finishexchange!" href="#CLIMA.CLIMAAtmosDycore.AtmosStateArrays.finishexchange!"><code>CLIMA.CLIMAAtmosDycore.AtmosStateArrays.finishexchange!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">finishexchange!(Q::AtmosStateArray)</code></pre><p>Complete the exchange of data and fill the data array on the device</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/AtmosStateArrays.jl#L219-L223">source</a></section><h2><a class="nav-anchor" id="Grids-1" href="#Grids-1"><code>Grids</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.Grids.DiscontinuousSpectralElementGrid" href="#CLIMA.CLIMAAtmosDycore.Grids.DiscontinuousSpectralElementGrid"><code>CLIMA.CLIMAAtmosDycore.Grids.DiscontinuousSpectralElementGrid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,
                                 polynomialorder,
                                 meshwarp = (x...)-&gt;identity(x))</code></pre><p>Generate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a <code>topology</code>, where the order of the elements is given by <code>polynomialorder</code>. <code>DeviceArray</code> gives the array type used to store the data (<code>CuArray</code> or <code>Array</code>), and the coordinate points will be of <code>FloatType</code>.</p><p>The optional <code>meshwarp</code> function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/Grids.jl#L26-L40">source</a></section><h2><a class="nav-anchor" id="Topologies-1" href="#Topologies-1"><code>Topologies</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.Topologies.BrickTopology" href="#CLIMA.CLIMAAtmosDycore.Topologies.BrickTopology"><code>CLIMA.CLIMAAtmosDycore.Topologies.BrickTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)</code></pre><p>Generate a brick mesh topology with coordinates given by the tuple <code>elemrange</code> and the periodic dimensions given by the <code>periodicity</code> tuple.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x_2$</span>-direction with</p><pre><code class="language-julia">
using CLIMAAtmosDycore
using CLIMAAtmosDycore.Topologies
using MPI
MPI.Init()
topology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);
                         periodicity=(false,true),
                         boundary=[1 3; 2 4])
MPI.Finalize()</code></pre><p>This returns the mesh structure for</p><pre><code class="language-none">         x_2

          ^
          |
         6-  +-----+-----+-----+
          |  |     |     |     |
          |  |  3  |  4  |  5  |
          |  |     |     |     |
         5-  +-----+-----+-----+
          |  |     |     |     |
          |  |  1  |  2  |  6  |
          |  |     |     |     |
         4-  +-----+-----+-----+
          |
          +--|-----|-----|-----|--&gt; x_1
             2     3     4     5</code></pre><p>For example, the (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-jldoctes">julia&gt; topology.elemtocoord
2×4×6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 3  4  3  4
 4  4  5  5

[:, :, 3] =
 2  3  2  3
 5  5  6  6

[:, :, 4] =
 3  4  3  4
 5  5  6  6

[:, :, 5] =
 4  5  4  5
 5  5  6  6

[:, :, 6] =
 4  5  4  5
 4  4  5  5</code></pre><p>Note that the corners are listed in Cartesian order.</p><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtobndy
4×6 Array{Int64,2}:
 1  0  1  0  0  0
 0  0  0  0  2  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>We may/probably want to unify to a single Topology type which has different constructors since all the topologies we currently have are essentially the same</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/Topologies.jl#L12-L110">source</a></section><h2><a class="nav-anchor" id="VanillaAtmosDiscretizations-1" href="#VanillaAtmosDiscretizations-1"><code>VanillaAtmosDiscretizations</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.VanillaAtmosDiscretization" href="#CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.VanillaAtmosDiscretization"><code>CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.VanillaAtmosDiscretization</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">VanillaAtmosDiscretization{nmoist, ntrace}(grid; gravity = true,
viscosity = 0)</code></pre><p>Given a &#39;grid &lt;: AbstractGrid&#39; this construct all the data necessary to run a vanilla discontinuous Galerkin discretization of the the compressible Euler equations with <code>nmoist</code> moisture variables and <code>ntrace</code> tracer variables. If the boolean keyword argument <code>gravity</code> is <code>true</code> then gravity is used otherwise it is not. Isotropic viscosity can be used if <code>viscosity</code> is set to a positive constant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/VanillaAtmosDiscretizations.jl#L27-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.estimatedt" href="#CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.estimatedt"><code>CLIMA.CLIMAAtmosDycore.VanillaAtmosDiscretizations.estimatedt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">estimatedt(disc::VanillaAtmosDiscretization, Q::AtmosStateArray)</code></pre><p>Given a discretization <code>disc</code> and a state <code>Q</code> compute an estimate for the time step</p><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>This estimate is currently very conservative, needs to be revisited</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/VanillaAtmosDiscretizations.jl#L184-L193">source</a></section><h2><a class="nav-anchor" id="LSRKmethods-1" href="#LSRKmethods-1"><code>LSRKmethods</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.CLIMAAtmosDycore.LSRKmethods.LSRK" href="#CLIMA.CLIMAAtmosDycore.LSRKmethods.LSRK"><code>CLIMA.CLIMAAtmosDycore.LSRKmethods.LSRK</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LSRK(f, Q; dt, t0 = 0)</code></pre><p>This is a time stepping object for explicitly time stepping the differential equation given by the right-hand-side function <code>f</code> with the state <code>Q</code>, i.e.,</p><pre><code class="language-none">Q̇ = f(Q)</code></pre><p>with the required time step size <code>dt</code> and optional initial time <code>t0</code>.  This time stepping object is intended to be passed to the <code>solve!</code> command.</p><p>This uses the fourth-order, low-storage, Runge–Kutta scheme of Carpenter and Kennedy (1994) (in their notation (5,4) 2N-Storage RK scheme).</p><p><strong>References</strong></p><pre><code class="language-none">@TECHREPORT{CarpenterKennedy1994,
  author = {M.~H. Carpenter and C.~A. Kennedy},
  title = {Fourth-order {2N-storage} {Runge-Kutta} schemes},
  institution = {National Aeronautics and Space Administration},
  year = {1994},
  number = {NASA TM-109112},
  address = {Langley Research Center, Hampton, VA},
}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/3a5522471f50edb58e23289318a21d2f781c12ed/src/ClimaAtmos/Dycore/src/LSRKmethods.jl#L17-L41">source</a></section><footer><hr/><a class="previous" href="../Utilities/"><span class="direction">Previous</span><span class="title"><code>Utilities</code></span></a><a class="next" href="../CodingConventions/"><span class="direction">Next</span><span class="title">Coding Conventions</span></a></footer></article></body></html>
